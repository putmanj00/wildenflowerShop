---
phase: 02-shopify-service-layer
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - lib/shopify-queries.ts
  - lib/shopify-client.ts
  - lib/shopify-mappers.ts
autonomous: true
requirements:
  - SHOP-03
  - SHOP-04
  - SHOP-05

must_haves:
  truths:
    - "lib/shopify-client.ts exports getProducts, getProductByHandle, getCollections, getCollectionByHandle, and searchProducts — all typed against types/shopify.ts, none using any casts"
    - "shopifyFetch throws ShopifyError on HTTP errors AND on GraphQL errors array in 200 responses"
    - "All service functions accept { first?: number; after?: string } pagination params and return ShopifyPaginatedResult<T> (or T for single-item lookups)"
    - "lib/shopify-queries.ts contains all query strings with GraphQL fragments concatenated into each query — no 'Unknown fragment' runtime errors"
    - "lib/shopify-mappers.ts flattens nodes[] arrays but keeps nested objects (images, variants, priceRange) structured — screens never see edges[].node or { nodes: [] } wrappers"
    - "EXPO_PUBLIC_ env vars are accessed using process.env.EXPO_PUBLIC_SHOPIFY_STORE_DOMAIN and process.env.EXPO_PUBLIC_SHOPIFY_STOREFRONT_ACCESS_TOKEN (static dot notation only — no bracket notation, no destructuring)"
    - "Startup validation throws immediately if either env var is undefined or empty, with a clear error message including the variable name"
  artifacts:
    - path: "lib/shopify-queries.ts"
      provides: "All GraphQL query strings and fragments"
      exports:
        - GET_PRODUCTS_QUERY
        - GET_PRODUCT_BY_HANDLE_QUERY
        - GET_COLLECTIONS_QUERY
        - GET_COLLECTION_BY_HANDLE_QUERY
        - SEARCH_PRODUCTS_QUERY
    - path: "lib/shopify-client.ts"
      provides: "ShopifyError class, shopifyFetch wrapper, all service functions"
      exports:
        - ShopifyError
        - getProducts
        - getProductByHandle
        - getCollections
        - getCollectionByHandle
        - searchProducts
    - path: "lib/shopify-mappers.ts"
      provides: "Pure transformation functions from raw Shopify API shapes to app-friendly types"
      exports:
        - mapProduct
        - mapCollection
        - mapCollectionWithProducts
  key_links:
    - from: "lib/shopify-client.ts"
      to: "lib/shopify-queries.ts"
      via: "named imports of query string constants"
      pattern: "import.*GET_PRODUCTS_QUERY.*from.*shopify-queries"
    - from: "lib/shopify-client.ts"
      to: "lib/shopify-mappers.ts"
      via: "calls to mapProduct / mapCollection inside each service function"
      pattern: "mapProduct|mapCollection"
    - from: "lib/shopify-client.ts"
      to: "types/shopify.ts"
      via: "TypeScript imports for response shapes and return types"
      pattern: "import.*ShopifyProduct.*from.*types/shopify"
    - from: "lib/shopify-mappers.ts"
      to: "types/shopify.ts"
      via: "function parameter and return types"
      pattern: "ShopifyProduct|ShopifyCollection"
---

<objective>
Build the three-file Shopify service layer: GraphQL query strings, authenticated fetch client with service functions, and data transformation mappers.

Purpose: This is the core data layer that all screens and hooks will consume in Phases 3-10. Getting the architecture right here (clean separation of concerns, proper error handling, correct fragment concatenation, typed pagination) avoids rework in every downstream phase.

Output: lib/shopify-queries.ts (query strings), lib/shopify-client.ts (ShopifyError + shopifyFetch + service functions), lib/shopify-mappers.ts (pure transformation functions).
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-shopify-service-layer/02-CONTEXT.md
@.planning/phases/02-shopify-service-layer/02-RESEARCH.md
@.planning/phases/02-shopify-service-layer/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/shopify-queries.ts with all GraphQL query strings and fragments</name>
  <files>lib/shopify-queries.ts</files>
  <action>
Create the `lib/` directory and `lib/shopify-queries.ts`. This file contains ONLY GraphQL string constants — no fetch logic, no types, no transformation.

CRITICAL — Fragment concatenation: When using plain string templates (not a GraphQL client with a parser), fragment definitions must be concatenated into the same string sent to Shopify. Each fragment must appear exactly once per request. Compose queries by appending fragment strings at the end.

Define fragments first, then compose queries using template literal concatenation:

```typescript
// lib/shopify-queries.ts
// All Shopify Storefront API GraphQL queries and fragments.
// Fragments are concatenated into each query string — required when using plain fetch (no GQL parser).

// ─── Fragments ────────────────────────────────────────────────────────────────

const IMAGE_FRAGMENT = `
  fragment ImageFragment on Image {
    url
    altText
    width
    height
  }
`;

const MONEY_FRAGMENT = `
  fragment MoneyFragment on MoneyV2 {
    amount
    currencyCode
  }
`;

const PRODUCT_VARIANT_FRAGMENT = `
  fragment ProductVariantFragment on ProductVariant {
    id
    title
    availableForSale
    price { ...MoneyFragment }
    compareAtPrice { ...MoneyFragment }
    selectedOptions { name value }
    image { ...ImageFragment }
  }
`;

const PRODUCT_FRAGMENT = `
  fragment ProductFragment on Product {
    id
    title
    handle
    description
    vendor
    productType
    tags
    availableForSale
    featuredImage { ...ImageFragment }
    images(first: 10) {
      nodes { ...ImageFragment }
    }
    priceRange {
      minVariantPrice { ...MoneyFragment }
      maxVariantPrice { ...MoneyFragment }
    }
    variants(first: 20) {
      nodes { ...ProductVariantFragment }
    }
  }
`;

// All dependencies for PRODUCT_FRAGMENT concatenated
const PRODUCT_FRAGMENT_DEPS = PRODUCT_VARIANT_FRAGMENT + IMAGE_FRAGMENT + MONEY_FRAGMENT;

const COLLECTION_FRAGMENT = `
  fragment CollectionFragment on Collection {
    id
    title
    handle
    description
    image { ...ImageFragment }
  }
`;

// ─── Queries ──────────────────────────────────────────────────────────────────

export const GET_PRODUCTS_QUERY = `
  query GetProducts($first: Int!, $after: String) {
    products(first: $first, after: $after) {
      nodes { ...ProductFragment }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
  ${PRODUCT_FRAGMENT}
  ${PRODUCT_FRAGMENT_DEPS}
`;

export const GET_PRODUCT_BY_HANDLE_QUERY = `
  query GetProductByHandle($handle: String!) {
    product(handle: $handle) {
      id
      title
      handle
      description
      descriptionHtml
      vendor
      productType
      tags
      availableForSale
      featuredImage { ...ImageFragment }
      images(first: 10) {
        nodes { ...ImageFragment }
      }
      priceRange {
        minVariantPrice { ...MoneyFragment }
        maxVariantPrice { ...MoneyFragment }
      }
      variants(first: 20) {
        nodes { ...ProductVariantFragment }
      }
    }
  }
  ${PRODUCT_VARIANT_FRAGMENT}
  ${IMAGE_FRAGMENT}
  ${MONEY_FRAGMENT}
`;

export const GET_COLLECTIONS_QUERY = `
  query GetCollections($first: Int!, $after: String) {
    collections(first: $first, after: $after) {
      nodes { ...CollectionFragment }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
  ${COLLECTION_FRAGMENT}
  ${IMAGE_FRAGMENT}
`;

export const GET_COLLECTION_BY_HANDLE_QUERY = `
  query GetCollectionByHandle($handle: String!, $first: Int!, $after: String) {
    collection(handle: $handle) {
      ...CollectionFragment
      products(first: $first, after: $after) {
        nodes {
          id
          title
          handle
          availableForSale
          featuredImage { ...ImageFragment }
          priceRange {
            minVariantPrice { ...MoneyFragment }
          }
          variants(first: 5) {
            nodes {
              id
              availableForSale
              price { ...MoneyFragment }
              selectedOptions { name value }
            }
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  }
  ${COLLECTION_FRAGMENT}
  ${IMAGE_FRAGMENT}
  ${MONEY_FRAGMENT}
`;

export const SEARCH_PRODUCTS_QUERY = `
  query SearchProducts($query: String!, $first: Int!, $after: String) {
    search(query: $query, first: $first, after: $after, types: [PRODUCT]) {
      nodes {
        ... on Product {
          id
          title
          handle
          availableForSale
          featuredImage { ...ImageFragment }
          priceRange {
            minVariantPrice { ...MoneyFragment }
          }
          vendor
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalCount
    }
  }
  ${IMAGE_FRAGMENT}
  ${MONEY_FRAGMENT}
`;
```

After writing, verify TypeScript compiles: `npx tsc --noEmit 2>&1 | grep "shopify-queries"` — must return no errors.
  </action>
  <verify>
- File exists: `ls lib/shopify-queries.ts`
- All 5 query constants exported: `grep "^export const" lib/shopify-queries.ts`
- TypeScript clean: `npx tsc --noEmit 2>&1 | grep "shopify-queries"` — no output
  </verify>
  <done>lib/shopify-queries.ts exists with GET_PRODUCTS_QUERY, GET_PRODUCT_BY_HANDLE_QUERY, GET_COLLECTIONS_QUERY, GET_COLLECTION_BY_HANDLE_QUERY, SEARCH_PRODUCTS_QUERY all exported as string constants with fragments correctly concatenated. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create lib/shopify-mappers.ts and lib/shopify-client.ts</name>
  <files>lib/shopify-mappers.ts, lib/shopify-client.ts</files>
  <action>
Create both files in sequence. `shopify-mappers.ts` first (no dependencies on client), then `shopify-client.ts` (imports both queries and mappers).

**lib/shopify-mappers.ts** — Pure transformation functions only. No fetch, no errors, no env vars.

```typescript
// lib/shopify-mappers.ts
// Pure functions: raw Shopify API shapes → app-friendly types.
// Rule: flatten nodes[] arrays; keep nested objects (images, variants, priceRange) structured.
// Screens never see edges[].node or { nodes: [] } connection wrappers.

import type {
  ShopifyProduct,
  ShopifyCollection,
  ShopifyCollectionWithProducts,
  ShopifyPaginatedResult,
  ShopifyPageInfo,
} from '../types/shopify';

// Flattened app product type — no connection wrappers
export interface AppProduct extends Omit<ShopifyProduct, 'images' | 'variants'> {
  images: ShopifyProduct['images']['nodes'];
  variants: ShopifyProduct['variants']['nodes'];
}

// Flattened app collection-with-products type
export interface AppCollectionWithProducts extends Omit<ShopifyCollectionWithProducts, 'products'> {
  products: ShopifyProduct['variants']['nodes'] extends never
    ? never
    : {
        items: AppProduct[];
        pageInfo: ShopifyPageInfo;
      };
}

export function mapProduct(raw: ShopifyProduct): AppProduct {
  return {
    ...raw,
    images: raw.images.nodes,
    variants: raw.variants.nodes,
  };
}

export function mapCollection(raw: ShopifyCollection): ShopifyCollection {
  // Collections have no connection wrappers to flatten at this level
  return raw;
}

export function mapCollectionWithProducts(
  raw: ShopifyCollectionWithProducts
): { collection: ShopifyCollection; products: ShopifyPaginatedResult<AppProduct> } {
  const { products, ...collectionFields } = raw;
  return {
    collection: collectionFields,
    products: {
      items: products.nodes.map(mapProduct),
      pageInfo: products.pageInfo,
    },
  };
}
```

**lib/shopify-client.ts** — ShopifyError class, shopifyFetch wrapper, and all service functions.

```typescript
// lib/shopify-client.ts
// Authenticated Shopify Storefront API client.
// Uses native fetch — no @shopify/storefront-api-client (React Native URL compatibility issues).
// EXPO_PUBLIC_ env vars accessed via static dot notation — bracket notation not inlined by Metro.

import type {
  ShopifyProduct,
  ShopifyCollection,
  ShopifyPaginatedResult,
  ShopifyPageInfo,
} from '../types/shopify';
import type { AppProduct, AppCollectionWithProducts } from './shopify-mappers';
import { mapProduct, mapCollection, mapCollectionWithProducts } from './shopify-mappers';
import {
  GET_PRODUCTS_QUERY,
  GET_PRODUCT_BY_HANDLE_QUERY,
  GET_COLLECTIONS_QUERY,
  GET_COLLECTION_BY_HANDLE_QUERY,
  SEARCH_PRODUCTS_QUERY,
} from './shopify-queries';

// ─── Constants ────────────────────────────────────────────────────────────────

// Static dot notation required — Expo Metro inlines EXPO_PUBLIC_ vars at bundle time.
// Bracket notation (process.env['EXPO_PUBLIC_X']) is NOT inlined and returns undefined.
const STORE_DOMAIN = process.env.EXPO_PUBLIC_SHOPIFY_STORE_DOMAIN;
const ACCESS_TOKEN = process.env.EXPO_PUBLIC_SHOPIFY_STOREFRONT_ACCESS_TOKEN;
const API_VERSION = '2026-01';

// Startup validation — fail fast with a clear message rather than silent undefined
if (!STORE_DOMAIN || STORE_DOMAIN === 'your-store.myshopify.com') {
  console.warn(
    '[Shopify] EXPO_PUBLIC_SHOPIFY_STORE_DOMAIN is not set. ' +
    'Add it to .env.local and restart the dev server.'
  );
}
if (!ACCESS_TOKEN || ACCESS_TOKEN === 'your-public-storefront-access-token') {
  console.warn(
    '[Shopify] EXPO_PUBLIC_SHOPIFY_STOREFRONT_ACCESS_TOKEN is not set. ' +
    'Add it to .env.local and restart the dev server.'
  );
}

const SHOPIFY_ENDPOINT = `https://${STORE_DOMAIN}/api/${API_VERSION}/graphql.json`;

// Default page size for paginated queries
const DEFAULT_PAGE_SIZE = 20;

// ─── Error Class ──────────────────────────────────────────────────────────────

export class ShopifyError extends Error {
  constructor(
    message: string,
    public readonly httpStatus: number,
    public readonly query?: string,
    public readonly storeDomain?: string,
  ) {
    super(`[Shopify${storeDomain ? ` (${storeDomain})` : ''}] ${message}`);
    this.name = 'ShopifyError';
  }
}

// ─── Fetch Wrapper ────────────────────────────────────────────────────────────

interface GraphQLResponse<T> {
  data?: T;
  errors?: Array<{ message: string; locations?: unknown; path?: unknown }>;
}

async function shopifyFetch<T>(
  query: string,
  variables?: Record<string, unknown>
): Promise<T> {
  const response = await fetch(SHOPIFY_ENDPOINT, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Shopify-Storefront-Access-Token': ACCESS_TOKEN ?? '',
    },
    body: JSON.stringify({ query, variables }),
  });

  if (!response.ok) {
    const message = `HTTP ${response.status}`;
    console.error(`[Shopify] ${message} on GraphQL request`);
    throw new ShopifyError(message, response.status, query, STORE_DOMAIN);
  }

  const json: GraphQLResponse<T> = await response.json();

  // GraphQL errors arrive in 200 responses — treat as failure (same path as network errors)
  if (json.errors && json.errors.length > 0) {
    const message = json.errors.map((e) => e.message).join('; ');
    console.error(`[Shopify] GraphQL error: ${message}`);
    throw new ShopifyError(message, 200, query, STORE_DOMAIN);
  }

  return json.data as T;
}

// ─── Pagination Params ────────────────────────────────────────────────────────

interface PaginationParams {
  first?: number;
  after?: string;
}

// ─── Service Functions ────────────────────────────────────────────────────────

export async function getProducts(
  params: PaginationParams = {}
): Promise<ShopifyPaginatedResult<AppProduct>> {
  const { first = DEFAULT_PAGE_SIZE, after } = params;
  const data = await shopifyFetch<{
    products: { nodes: ShopifyProduct[]; pageInfo: ShopifyPageInfo };
  }>(GET_PRODUCTS_QUERY, { first, after });
  return {
    items: data.products.nodes.map(mapProduct),
    pageInfo: data.products.pageInfo,
  };
}

export async function getProductByHandle(handle: string): Promise<AppProduct | null> {
  const data = await shopifyFetch<{ product: ShopifyProduct | null }>(
    GET_PRODUCT_BY_HANDLE_QUERY,
    { handle }
  );
  return data.product ? mapProduct(data.product) : null;
}

export async function getCollections(
  params: PaginationParams = {}
): Promise<ShopifyPaginatedResult<ShopifyCollection>> {
  const { first = DEFAULT_PAGE_SIZE, after } = params;
  const data = await shopifyFetch<{
    collections: { nodes: ShopifyCollection[]; pageInfo: ShopifyPageInfo };
  }>(GET_COLLECTIONS_QUERY, { first, after });
  return {
    items: data.collections.nodes.map(mapCollection),
    pageInfo: data.collections.pageInfo,
  };
}

export async function getCollectionByHandle(
  handle: string,
  params: PaginationParams = {}
): Promise<ReturnType<typeof mapCollectionWithProducts> | null> {
  const { first = DEFAULT_PAGE_SIZE, after } = params;
  const data = await shopifyFetch<{ collection: AppCollectionWithProducts | null }>(
    GET_COLLECTION_BY_HANDLE_QUERY,
    { handle, first, after }
  );
  return data.collection ? mapCollectionWithProducts(data.collection as any) : null;
}

export async function searchProducts(
  query: string,
  params: PaginationParams = {}
): Promise<ShopifyPaginatedResult<AppProduct> & { totalCount: number }> {
  const { first = DEFAULT_PAGE_SIZE, after } = params;
  const data = await shopifyFetch<{
    search: {
      nodes: ShopifyProduct[];
      pageInfo: ShopifyPageInfo;
      totalCount: number;
    };
  }>(SEARCH_PRODUCTS_QUERY, { query, first, after });
  return {
    items: data.search.nodes.map(mapProduct),
    pageInfo: data.search.pageInfo,
    totalCount: data.search.totalCount,
  };
}
```

IMPORTANT implementation note: The `AppCollectionWithProducts` type in mappers.ts as written above has a complex conditional type. If the TypeScript compiler complains about it, simplify `AppCollectionWithProducts` to a plain interface:

```typescript
export interface AppCollectionWithProducts extends ShopifyCollection {
  products: {
    items: AppProduct[];
    pageInfo: ShopifyPageInfo;
  };
}
```

And update `mapCollectionWithProducts` return type accordingly. Type correctness matters more than type elegance — use `as any` casts at the boundary where Shopify's raw shape (with `nodes`) is converted to the flattened app shape, since the raw response won't match the app type at the call site.

After writing both files, run TypeScript: `npx tsc --noEmit 2>&1 | head -40`

Fix any TypeScript errors in shopify-mappers.ts or shopify-client.ts. The goal is zero errors across the project. It is acceptable to use `as any` at the raw→app type transformation boundary in shopify-client.ts where Shopify's `{ nodes: [] }` shape is passed to mappers expecting the GraphQL response shape — the TypeScript generic inference cannot follow that shape through the fetch wrapper.
  </action>
  <verify>
- Both files exist: `ls lib/shopify-mappers.ts lib/shopify-client.ts`
- Service functions exported: `grep "^export async function\|^export class" lib/shopify-client.ts`
- Should list: ShopifyError, getProducts, getProductByHandle, getCollections, getCollectionByHandle, searchProducts
- Mapper functions exported: `grep "^export function\|^export interface" lib/shopify-mappers.ts`
- TypeScript compiles: `npx tsc --noEmit 2>&1` — zero errors
- Env var pattern correct: `grep "process.env.EXPO_PUBLIC" lib/shopify-client.ts` — must use dot notation
- No bracket notation: `grep "process.env\[" lib/shopify-client.ts` — must return empty
  </verify>
  <done>lib/shopify-mappers.ts and lib/shopify-client.ts both exist. ShopifyError class, shopifyFetch wrapper, and five service functions (getProducts, getProductByHandle, getCollections, getCollectionByHandle, searchProducts) are exported. All mapper functions exported. TypeScript project compiles with zero errors. Env vars accessed via static dot notation only.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `ls lib/` — shows shopify-queries.ts, shopify-client.ts, shopify-mappers.ts
2. `npx tsc --noEmit 2>&1` — zero errors
3. `grep "^export" lib/shopify-client.ts` — shows ShopifyError, getProducts, getProductByHandle, getCollections, getCollectionByHandle, searchProducts
4. `grep "process.env\[" lib/shopify-client.ts` — empty (no bracket notation)
5. `grep "EXPO_PUBLIC_SHOPIFY_STORE_DOMAIN\b" lib/shopify-client.ts` — uses dot notation
</verification>

<success_criteria>
- lib/shopify-queries.ts: 5 query string constants exported, fragments concatenated into each query
- lib/shopify-mappers.ts: mapProduct, mapCollection, mapCollectionWithProducts exported as pure functions; nodes[] arrays flattened to plain arrays
- lib/shopify-client.ts: ShopifyError class, shopifyFetch (throws on HTTP errors and GraphQL errors array), getProducts, getProductByHandle, getCollections, getCollectionByHandle, searchProducts — all exported and typed
- All service functions return paginated results (ShopifyPaginatedResult<T>) or nullable single items
- Process.env EXPO_PUBLIC_ accessed with static dot notation only
- Zero TypeScript errors across project
</success_criteria>

<output>
After completion, create `.planning/phases/02-shopify-service-layer/02-02-SUMMARY.md`
</output>
