---
phase: 04-data-hooks-checkout-wiring
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - context/CartContext.tsx
autonomous: true
requirements: [SHOP-08]

must_haves:
  truths:
    - "CartContext exposes checkoutUrl: string | null — populated after every cart mutation and on hydration"
    - "CartContext exposes openCheckout() — calling it from a button tap opens Shopify checkout"
    - "On web, openCheckout() uses window.location.href (same-tab, popup-block-proof)"
    - "On native, openCheckout() uses Linking.openURL with the pre-fetched URL (synchronous from gesture)"
    - "checkoutUrl is never persisted to AsyncStorage — always re-derived from live cart response"
    - "The checkout button can disable itself by checking !checkoutUrl || isLoading"
    - "checkoutUrl is null while the cart is empty or during hydration"
  artifacts:
    - path: "context/CartContext.tsx"
      provides: "Extended CartContext with checkoutUrl + openCheckout"
      contains: "checkoutUrl"
      exports: ["CartProvider", "useCart"]
  key_links:
    - from: "context/CartContext.tsx"
      to: "ShopifyCart.checkoutUrl"
      via: "updateCartState helper calling setCheckoutUrl(newCart.checkoutUrl)"
      pattern: "setCheckoutUrl"
    - from: "context/CartContext.tsx"
      to: "Platform.OS"
      via: "openCheckout() branch"
      pattern: "Platform\\.OS.*web|window\\.location\\.href"
    - from: "context/CartContext.tsx"
      to: "Linking.openURL"
      via: "native branch of openCheckout()"
      pattern: "Linking\\.openURL"
---

<objective>
Extend CartContext with `checkoutUrl: string | null` state and `openCheckout()` action. The checkoutUrl is already present in every ShopifyCart response (it's in CART_LINES_FRAGMENT) — CartContext just needs to extract and expose it. The openCheckout() action branches on Platform.OS to use window.location.href on web (same-tab, popup-block-proof) and Linking.openURL on native (synchronous from user gesture).

Purpose: Fulfill SHOP-08 — checkout must open Shopify's cart.checkoutUrl in browser. The pre-fetched URL enables the checkout button to open synchronously from a tap handler, avoiding popup blockers on web.

Output: context/CartContext.tsx extended with checkoutUrl state, updateCartState helper, and openCheckout() action — all existing cart mutations and behavior unchanged.
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-hooks-checkout-wiring/04-CONTEXT.md
@.planning/phases/04-data-hooks-checkout-wiring/04-RESEARCH.md
@context/CartContext.tsx
@types/shopify.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend CartContext with checkoutUrl state and openCheckout action</name>
  <files>context/CartContext.tsx</files>
  <action>
Extend the existing `context/CartContext.tsx` to add `checkoutUrl` state and `openCheckout()` action. DO NOT rewrite the file — make targeted additions preserving all existing behavior.

**Step 1 — Add imports at top of file:**
Add `Platform, Linking` from 'react-native':
```typescript
import { Platform, Linking } from 'react-native';
```
(Add alongside existing React import line. Linking is from 'react-native', not 'expo-linking' — confirmed in RESEARCH.md.)

**Step 2 — Add fields to CartContextType interface:**
After the existing `cartTotal: number` field, add:
```typescript
  // Checkout
  checkoutUrl: string | null;
  openCheckout: () => void;
```

**Step 3 — Add state variable inside CartProvider:**
After the existing `isUpdatingQuantity` useState declaration, add:
```typescript
  const [checkoutUrl, setCheckoutUrl] = useState<string | null>(null);
```

**Step 4 — Add updateCartState helper inside CartProvider:**
After the `persistCart` helper reference (or immediately before the mutations section), add a new helper:
```typescript
  /**
   * Single point for updating cart state — always extracts checkoutUrl alongside cart.
   * Use this instead of bare setCart() calls to guarantee checkoutUrl stays in sync.
   */
  function updateCartState(newCart: ShopifyCart): void {
    setCart(newCart);
    setCheckoutUrl(newCart.checkoutUrl);
  }
```

**Step 5 — Replace all `setCart(...)` calls with `updateCartState(...)`:**
Find every bare `setCart(newCart)` or `setCart(existingCart)` call in CartProvider and replace with `updateCartState(newCart)` / `updateCartState(existingCart)`. There are several call sites:
- In hydration useEffect: `setCart(existingCart)` → `updateCartState(existingCart)`
- In hydration useEffect (recovery): `setCart(newCart)` → `updateCartState(newCart)`
- In `addToCart`: `setCart(newCart)` → `updateCartState(newCart)`
- In `removeFromCart`: `setCart(newCart)` → `updateCartState(newCart)`
- In `updateQuantity`: `setCart(newCart)` → `updateCartState(newCart)`

Do NOT replace the rollback lines (`setCart(previousCart)`) — those restore old state on error and the previous cart's checkoutUrl was already captured; OR replace them with `updateCartState(previousCart)` if previousCart is non-null. For null rollback cases (`setCartId(null); setCart(null)`) keep as-is and add `setCheckoutUrl(null)` alongside.

**clearCart:** In `clearCart`, after `setCart(null)` add `setCheckoutUrl(null)`.

**Step 6 — Add openCheckout function inside CartProvider:**
```typescript
  const openCheckout = (): void => {
    if (!checkoutUrl) return; // button should be disabled, but guard defensively
    if (Platform.OS === 'web') {
      // window.location.href: same-tab navigation, cannot be popup-blocked
      // Linking.openURL on web uses window.open(..., '_blank') which can be blocked
      window.location.href = checkoutUrl;
    } else {
      // Native: open in device browser synchronously from user gesture
      Linking.openURL(checkoutUrl).catch(() => {
        // Silent no-op if native URL open fails (extremely rare edge case)
      });
    }
  };
```

**TypeScript note on `window`:** The project's tsconfig extends expo/tsconfig.base which includes "DOM" in its lib array — `window.location.href` is fully typed and TypeScript-legal without any type assertions. No `declare const window` needed.

**Step 7 — Expose new fields in context value:**
Add to the CartContext.Provider value object:
```typescript
        checkoutUrl,
        openCheckout,
```

**CRITICAL rules:**
- Do NOT persist checkoutUrl to AsyncStorage — URLs expire (CONTEXT.md locked decision)
- Do NOT add async logic to openCheckout — it must be synchronous from gesture to avoid popup-blocking
- Do NOT change any existing CartContextType fields, mutation signatures, or behavior
- Every path that calls `setCart(someCart)` where someCart is a ShopifyCart (not null) must also call `setCheckoutUrl(someCart.checkoutUrl)` — use updateCartState() for this
  </action>
  <verify>
1. `npx tsc --noEmit` from project root — zero TypeScript errors
2. Grep `context/CartContext.tsx` for `checkoutUrl` — should appear in: CartContextType interface, useState declaration, updateCartState helper, openCheckout function, context value object
3. Grep `context/CartContext.tsx` for `setCart(` — should return zero bare `setCart(newCart)` calls (all replaced by updateCartState); rollback `setCart(previousCart)` calls are acceptable if previousCart is typed as ShopifyCart | null and handled
4. Grep `context/CartContext.tsx` for `openCheckout` — should appear in CartContextType and context value
5. Grep `context/CartContext.tsx` for `window.location.href` — should appear once in openCheckout
6. Grep `context/CartContext.tsx` for `Linking.openURL` — should appear once in openCheckout
  </verify>
  <done>CartContextType includes `checkoutUrl: string | null` and `openCheckout: () => void`. Every cart mutation and hydration path sets checkoutUrl from newCart.checkoutUrl via updateCartState(). openCheckout() branches correctly on Platform.OS. npx tsc --noEmit exits 0.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` produces zero errors
2. CartContext.tsx contains updateCartState helper, checkoutUrl state, and openCheckout action
3. No bare `setCart(newCart)` calls remain — only updateCartState(newCart) and rollback setCart(previousCart) patterns
4. openCheckout correctly uses window.location.href on web, Linking.openURL on native
5. checkoutUrl is NOT referenced in any AsyncStorage.setItem call
6. CartProvider value object includes checkoutUrl and openCheckout
</verification>

<success_criteria>
- CartContext exposes checkoutUrl: string | null and openCheckout: () => void
- checkoutUrl is populated immediately after cart hydration (not null for an existing cart with items)
- openCheckout() is a synchronous void function — no async/await, no Promise
- Platform branching is correct: web uses window.location.href, native uses Linking.openURL
- All existing CartContext behavior (addToCart, removeFromCart, updateQuantity, clearCart, cartCount, cartTotal, isLoading flags) is preserved unchanged
- npx tsc --noEmit exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-hooks-checkout-wiring/04-02-SUMMARY.md`
</output>
