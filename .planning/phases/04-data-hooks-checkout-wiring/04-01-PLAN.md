---
phase: 04-data-hooks-checkout-wiring
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/useShopifyQuery.ts
  - hooks/useProducts.ts
  - hooks/useCollections.ts
  - hooks/useProduct.ts
autonomous: true
requirements: [SHOP-08]

must_haves:
  truths:
    - "useProducts() returns { products, loading, isRefetching, error, refetch } and fetches from Shopify service layer"
    - "useCollections() returns { collections, loading, isRefetching, error, refetch }"
    - "useProduct(handle) returns { product, loading, isRefetching, error, refetch } and re-fetches when handle changes"
    - "Calling refetch() clears error to null before re-fetching (optimistic reset)"
    - "loading is true only on initial fetch; isRefetching is true on subsequent refetch() calls"
    - "Rapid handle changes on useProduct do not produce race conditions — stale responses are discarded"
    - "Screens can import and use any hook without importing from lib/shopify-client directly"
  artifacts:
    - path: "hooks/useShopifyQuery.ts"
      provides: "Generic loading/isRefetching/error/refetch state machine"
      exports: ["useShopifyQuery"]
      min_lines: 40
    - path: "hooks/useProducts.ts"
      provides: "Shopify products hook with optional collection filter and limit"
      exports: ["useProducts"]
    - path: "hooks/useCollections.ts"
      provides: "Shopify collections hook with optional limit"
      exports: ["useCollections"]
    - path: "hooks/useProduct.ts"
      provides: "Single product hook by handle"
      exports: ["useProduct"]
  key_links:
    - from: "hooks/useProducts.ts"
      to: "lib/shopify-client.ts"
      via: "getProducts / getCollectionByHandle imports"
      pattern: "import.*getProducts|getCollectionByHandle.*shopify-client"
    - from: "hooks/useCollections.ts"
      to: "lib/shopify-client.ts"
      via: "getCollections import"
      pattern: "import.*getCollections.*shopify-client"
    - from: "hooks/useProduct.ts"
      to: "lib/shopify-client.ts"
      via: "getProductByHandle import"
      pattern: "import.*getProductByHandle.*shopify-client"
    - from: "hooks/useProducts.ts"
      to: "hooks/useShopifyQuery.ts"
      via: "useShopifyQuery import"
      pattern: "import.*useShopifyQuery"
---

<objective>
Create the shared data-fetching infrastructure for the app: a generic `useShopifyQuery<T>` base hook managing the loading/isRefetching/error/refetch state machine, then three thin public hooks (`useProducts`, `useCollections`, `useProduct`) that wrap the existing Shopify service layer.

Purpose: Establish the abstraction layer between screens and the Shopify service layer. Screens will NEVER import from lib/shopify-client directly — they call hooks. This decouples screens from Shopify API shapes and ensures consistent loading/error handling across all data fetching.

Output: 4 new files in hooks/ — useShopifyQuery.ts (base), useProducts.ts, useCollections.ts, useProduct.ts.
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-hooks-checkout-wiring/04-CONTEXT.md
@.planning/phases/04-data-hooks-checkout-wiring/04-RESEARCH.md
@lib/shopify-client.ts
@lib/shopify-mappers.ts
@types/shopify.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useShopifyQuery base hook</name>
  <files>hooks/useShopifyQuery.ts</files>
  <action>
Create `hooks/useShopifyQuery.ts` — a generic hook that manages the shared loading/isRefetching/error/refetch state machine used by all three public hooks.

**Interface:**
```typescript
interface UseShopifyQueryResult<T> {
  data: T | null;
  loading: boolean;       // true only on initial fetch (data is null and no error)
  isRefetching: boolean;  // true on subsequent refetch() calls
  error: string | null;
  refetch: () => void;    // clears error to null optimistically before re-fetching
}

export function useShopifyQuery<T>(
  queryFn: () => Promise<T>,
  deps: unknown[] = []
): UseShopifyQueryResult<T>
```

**Implementation requirements:**

1. State: `data: T | null`, `loading: boolean` (initial true), `isRefetching: boolean` (initial false), `error: string | null` (initial null), `refetchTrigger: number` (counter).

2. `refetch()` function: wrapped in `useCallback([])`; sets `error(null)` (optimistic reset per CONTEXT.md), increments `refetchTrigger` by 1.

3. `useEffect` with deps `[refetchTrigger, ...deps]`:
   - Declare `let cancelled = false`
   - Determine `isFirstLoad`: `data === null && error === null` — if true, set `loading(true)`, else set `isRefetching(true)`
   - Call `queryFn()` (async, no await at top level — use `.then/.catch/.finally`)
   - `.then((result)` → if not cancelled: `setData(result)`, `setError(null)`
   - `.catch((err: unknown)` → if not cancelled: extract message (`err instanceof Error ? err.message : 'Unknown error'`), `setError(message)`
   - `.finally(()` → if not cancelled: `setLoading(false)`, `setIsRefetching(false)`
   - Return cleanup: `() => { cancelled = true; }`
   - Add `// eslint-disable-next-line react-hooks/exhaustive-deps` before the deps array (spread pattern is non-standard)

4. Return `{ data, loading, isRefetching, error, refetch }`.

**Imports:** `useState`, `useEffect`, `useCallback` from 'react'.

**CRITICAL — queryFn stability:** The `queryFn` parameter is NOT in the deps array of the useEffect. Public hooks must wrap their queryFn in `useCallback` before passing. The base hook trusts that the caller provides a stable reference. Document this contract in a JSDoc comment above the function.

**CRITICAL — race condition prevention:** The `cancelled` flag ensures stale in-flight requests (e.g., old `useProduct(handle)` query after handle changes) cannot set state. When a dep changes, the old effect cleanup runs (`cancelled = true`) before the new effect starts.

**isFirstLoad tracking note:** After a successful fetch, `data` is no longer null, so subsequent `refetch()` calls correctly trigger `isRefetching` not `loading`. After an error, `error` is not null, so refetch also triggers `isRefetching`. Only the very first fetch (both null) triggers `loading`.
  </action>
  <verify>Run `npx tsc --noEmit` from project root — must produce zero TypeScript errors for hooks/useShopifyQuery.ts. Also confirm: file exports `useShopifyQuery`, imports are only from 'react', no `any` types.</verify>
  <done>hooks/useShopifyQuery.ts exists, exports `useShopifyQuery&lt;T&gt;`, TypeScript compiles clean, `cancelled` flag pattern and refetch state machine are implemented correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create useProducts, useCollections, useProduct public hooks</name>
  <files>hooks/useProducts.ts, hooks/useCollections.ts, hooks/useProduct.ts</files>
  <action>
Create three thin public hook wrappers that call `useShopifyQuery` with their specific service function.

**All three hooks follow the same pattern:**
- Destructure options into primitive values before `useCallback` (prevents object identity churn)
- Wrap `queryFn` in `useCallback` with correct primitive deps
- Pass `queryFn` and deps array to `useShopifyQuery`
- Reshape `data` from generic field to named field (e.g., `products: data ?? []`)

---

**hooks/useProducts.ts**

Options and return types:
```typescript
interface UseProductsOptions {
  collection?: string;   // Shopify collection handle; omit for all products
  limit?: number;        // default 20 (matches DEFAULT_PAGE_SIZE in service layer)
}

interface UseProductsResult {
  products: AppProduct[];
  loading: boolean;
  isRefetching: boolean;
  error: string | null;
  refetch: () => void;
}
```

Implementation:
- Destructure: `const { collection, limit = 20 } = options ?? {}`
- `queryFn`: if `collection` is truthy, call `getCollectionByHandle(collection, { first: limit })` and return `result?.products.items ?? []`; otherwise call `getProducts({ first: limit })` and return `result.items`
- `useCallback` deps: `[collection, limit]`
- Pass same deps to `useShopifyQuery`
- Return: `{ products: data ?? [], loading, isRefetching, error, refetch }`

Imports needed: `useCallback` from 'react', `useShopifyQuery` from './useShopifyQuery', `getProducts` and `getCollectionByHandle` from '../lib/shopify-client', `AppProduct` type from '../lib/shopify-mappers'.

---

**hooks/useCollections.ts**

Options and return types:
```typescript
interface UseCollectionsOptions {
  limit?: number;        // default 20 (consistent with useProducts)
}

interface UseCollectionsResult {
  collections: ShopifyCollection[];
  loading: boolean;
  isRefetching: boolean;
  error: string | null;
  refetch: () => void;
}
```

Implementation:
- Destructure: `const { limit = 20 } = options ?? {}`
- `queryFn`: call `getCollections({ first: limit }).then((r) => r.items)`
- `useCallback` deps: `[limit]`
- Pass same deps to `useShopifyQuery`
- Return: `{ collections: data ?? [], loading, isRefetching, error, refetch }`

Imports needed: `useCallback` from 'react', `useShopifyQuery` from './useShopifyQuery', `getCollections` from '../lib/shopify-client', `ShopifyCollection` type from '../types/shopify'.

---

**hooks/useProduct.ts**

Return type:
```typescript
interface UseProductResult {
  product: AppProduct | null;
  loading: boolean;
  isRefetching: boolean;
  error: string | null;
  refetch: () => void;
}
```

Implementation:
- Function signature: `export function useProduct(handle: string): UseProductResult`
- `queryFn`: `useCallback(() => getProductByHandle(handle), [handle])`
- Pass `[handle]` as deps to `useShopifyQuery` — handle change triggers re-fetch per CONTEXT.md locked decision
- Return: `{ product: data ?? null, loading, isRefetching, error, refetch }`

Imports needed: `useCallback` from 'react', `useShopifyQuery` from './useShopifyQuery', `getProductByHandle` from '../lib/shopify-client', `AppProduct` type from '../lib/shopify-mappers'.

---

**CRITICAL — Do NOT:**
- Import from lib/shopify-client in screens — hooks are the only access point
- Use inline object literals as useCallback deps (always destructure to primitives first)
- Add any caching, memoization, or focus-refetch logic — CONTEXT.md locks "fetch once on mount, no auto-refetch on focus"
- Use React Query, SWR, or any third-party data fetching library
  </action>
  <verify>Run `npx tsc --noEmit` from project root — zero errors across all four hook files. Grep confirms: no direct `getProducts`/`getCollections`/`getProductByHandle` imports exist anywhere in app/ or components/ (screens must use hooks, not call service layer directly). Each hook file exports exactly one named function.</verify>
  <done>hooks/useProducts.ts, hooks/useCollections.ts, and hooks/useProduct.ts all exist, TypeScript compiles clean, each exports its named hook with the correct { data-field, loading, isRefetching, error, refetch } return shape per CONTEXT.md locked decisions.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` from project root produces zero TypeScript errors
2. All four hook files exist in hooks/: useShopifyQuery.ts, useProducts.ts, useCollections.ts, useProduct.ts
3. Each hook exports exactly one named function matching the locked return shape from CONTEXT.md
4. `useShopifyQuery` uses `cancelled` flag pattern to prevent race conditions
5. `useCallback` is used in all three public hooks with primitive dep arrays (not object literals)
6. No direct service layer imports exist in app/ or components/ screens
</verification>

<success_criteria>
- hooks/useShopifyQuery.ts: exports useShopifyQuery&lt;T&gt;, implements loading/isRefetching distinction, cancelled flag cleanup, error clearing on refetch
- hooks/useProducts.ts: accepts { collection?, limit? }, calls getCollectionByHandle or getProducts depending on collection param, returns products array (empty array not null on loading)
- hooks/useCollections.ts: accepts { limit? }, returns collections array
- hooks/useProduct.ts: re-fetches when handle changes, returns product or null
- npx tsc --noEmit exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-hooks-checkout-wiring/04-01-SUMMARY.md`
</output>
