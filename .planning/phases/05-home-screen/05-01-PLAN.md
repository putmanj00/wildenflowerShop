---
phase: 05-home-screen
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/layout/ScrollScreen.tsx
  - components/HeroCard.tsx
  - components/SkeletonProductCard.tsx
autonomous: true
requirements: [COMM-01]

must_haves:
  truths:
    - "ScrollScreen forwards a refreshControl prop to its inner ScrollView"
    - "HeroCard renders a gold PrimaryButton when onExplorePress prop is provided"
    - "SkeletonProductCard renders a parchment-coloured two-row placeholder matching ProductCard dimensions"
  artifacts:
    - path: "components/layout/ScrollScreen.tsx"
      provides: "refreshControl prop forwarding"
      contains: "refreshControl?: React.ReactElement"
    - path: "components/HeroCard.tsx"
      provides: "onExplorePress button affordance"
      contains: "onExplorePress?: () => void"
    - path: "components/SkeletonProductCard.tsx"
      provides: "loading placeholder matching ProductCard dimensions"
      exports: ["default SkeletonProductCard"]
  key_links:
    - from: "components/layout/ScrollScreen.tsx"
      to: "React Native ScrollView"
      via: "refreshControl prop forwarding"
      pattern: "refreshControl={refreshControl}"
    - from: "components/HeroCard.tsx"
      to: "components/PrimaryButton.tsx"
      via: "conditional render"
      pattern: "onExplorePress && .*PrimaryButton"
---

<objective>
Prepare the three components that the Home screen wiring (Plan 02) depends on: extend ScrollScreen to support pull-to-refresh, add an explore button to HeroCard, and create the SkeletonProductCard loading placeholder.

Purpose: Plan 02 cannot wire pull-to-refresh, the HeroCard CTA, or the skeleton loading state without these component primitives in place first.
Output: Three modified/created component files — self-contained changes with no inter-plan conflicts.
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-home-screen/05-CONTEXT.md
@.planning/phases/05-home-screen/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ScrollScreen with refreshControl prop</name>
  <files>components/layout/ScrollScreen.tsx</files>
  <action>
Add `refreshControl?: React.ReactElement` to the `ScrollScreenProps` interface and forward it to the inner `ScrollView`.

Current interface (lines 21-25):
```
interface ScrollScreenProps {
  children?: React.ReactNode;
  style?: ViewStyle;
  contentContainerStyle?: ViewStyle;
}
```

Updated interface:
```
interface ScrollScreenProps {
  children?: React.ReactNode;
  style?: ViewStyle;
  contentContainerStyle?: ViewStyle;
  refreshControl?: React.ReactElement;
}
```

Add `refreshControl` to the destructured props in the function signature alongside `children`, `style`, `contentContainerStyle`.

Pass `refreshControl={refreshControl}` to the `<ScrollView>` element. The ScrollView already accepts this prop — no additional import needed.

No other changes to the file.
  </action>
  <verify>
TypeScript compiles without error. Confirm the prop appears in the interface and is forwarded to ScrollView: `grep -n "refreshControl" components/layout/ScrollScreen.tsx` should return 3 lines (interface, destructure, JSX prop).
  </verify>
  <done>ScrollScreen accepts and forwards `refreshControl?: React.ReactElement` to its inner ScrollView — pull-to-refresh is now wirable from any screen using ScrollScreen.</done>
</task>

<task type="auto">
  <name>Task 2: Add onExplorePress button to HeroCard</name>
  <files>components/HeroCard.tsx</files>
  <action>
Add an optional `onExplorePress?: () => void` prop to `HeroCardProps`. When provided, render a `PrimaryButton` (variant `'gold'`) inside `textCol`, below the `tagline` Text element, with a top margin of `spacing.lg` (16px).

Button label: `"Wander the Shop"` — follows the brand vocabulary from CLAUDE.md (wandering = discovering).

Import `PrimaryButton` from `'../components/PrimaryButton'` — wait, `HeroCard.tsx` is already in the `components/` directory, so the import should be `import PrimaryButton from './PrimaryButton'`.

Updated imports at top of file: add `import PrimaryButton from './PrimaryButton';`

Updated `HeroCardProps`:
```typescript
interface HeroCardProps {
  tagline?: string;
  onExplorePress?: () => void;
}
```

Updated function signature:
```typescript
export default function HeroCard({ tagline = copy.tagline, onExplorePress }: HeroCardProps)
```

Inside `<View style={styles.textCol}>`, after the `<Text style={styles.tagline}>` element:
```tsx
{onExplorePress && (
  <PrimaryButton
    label="Wander the Shop"
    onPress={onExplorePress}
    variant="gold"
  />
)}
```

Add a `marginTop: spacing.lg` wrapper or use the button's native spacing — add `exploreButton: { marginTop: spacing.lg }` to the StyleSheet and wrap:
```tsx
{onExplorePress && (
  <View style={styles.exploreButton}>
    <PrimaryButton
      label="Wander the Shop"
      onPress={onExplorePress}
      variant="gold"
    />
  </View>
)}
```

`exploreButton` style: `{ marginTop: spacing.lg }`.

Existing `HeroCard` renders without change when `onExplorePress` is not provided (backward compatible — the button does not appear).
  </action>
  <verify>
TypeScript compiles without error. Confirm button is conditionally rendered: `grep -n "onExplorePress" components/HeroCard.tsx` should return 4 lines (interface, destructure, conditional, prop). Confirm PrimaryButton import is present.
  </verify>
  <done>HeroCard renders a gold "Wander the Shop" PrimaryButton when `onExplorePress` prop is provided; renders identically to current when prop is absent.</done>
</task>

<task type="auto">
  <name>Task 3: Create SkeletonProductCard component</name>
  <files>components/SkeletonProductCard.tsx</files>
  <action>
Create `components/SkeletonProductCard.tsx` — a static parchment-coloured loading placeholder that mirrors `ProductCard` dimensions.

File header comment following project convention:
```typescript
/**
 * SkeletonProductCard — Loading placeholder for ProductCard
 * =========================================================
 * Renders a parchment-coloured card placeholder matching ProductCard dimensions.
 * Shown in the Home screen ProductGrid while Shopify products are fetching.
 */
```

Imports (follow project import order from CONVENTIONS.md):
```typescript
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';
import { colors, spacing, radii, shadows } from '../constants/theme';
```

Props interface:
```typescript
interface SkeletonProductCardProps {
  style?: ViewStyle;
}
```

Component body — three nested Views: card wrapper, image area placeholder, content area with name line and price line:
```typescript
export default function SkeletonProductCard({ style }: SkeletonProductCardProps) {
  return (
    <View style={[styles.card, style]}>
      <View style={styles.imageArea} />
      <View style={styles.contentArea}>
        <View style={styles.nameLine} />
        <View style={styles.priceLine} />
      </View>
    </View>
  );
}
```

StyleSheet — dimensions must match ProductCard's actual dimensions. `productCardImageHeight` is 160 from theme (confirmed in theme.ts). `cardPadding` is 16:
```typescript
const styles = StyleSheet.create({
  card: {
    backgroundColor: colors.parchmentDark,
    borderRadius: radii.card,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: colors.borderLight,
    ...shadows.sm,
  },
  imageArea: {
    height: spacing.productCardImageHeight,  // 160px
    backgroundColor: colors.border,
  },
  contentArea: {
    padding: spacing.cardPadding,
    gap: spacing.sm,
  },
  nameLine: {
    height: 14,
    width: '75%',
    backgroundColor: colors.border,
    borderRadius: radii.sm,
  },
  priceLine: {
    height: 18,
    width: '40%',
    backgroundColor: colors.borderLight,
    borderRadius: radii.sm,
  },
});
```

No animation — static placeholder only (shimmer is in Claude's discretion and explicitly not required per CONTEXT.md).
  </action>
  <verify>
File exists: `ls components/SkeletonProductCard.tsx`. TypeScript compiles without error. Confirm key style values: `grep -n "productCardImageHeight\|parchmentDark\|borderLight" components/SkeletonProductCard.tsx` returns all three token references.
  </verify>
  <done>SkeletonProductCard exists at `components/SkeletonProductCard.tsx`, uses only theme tokens, renders a card-shaped parchment placeholder at ProductCard dimensions (160px image area, text line placeholders).</done>
</task>

</tasks>

<verification>
After all three tasks:
1. `grep -n "refreshControl" components/layout/ScrollScreen.tsx` — returns 3 hits (interface, destructure, JSX)
2. `grep -n "onExplorePress\|Wander" components/HeroCard.tsx` — returns button prop and label
3. `ls components/SkeletonProductCard.tsx` — file exists
4. TypeScript check: `npx tsc --noEmit` — zero errors (or same count as before plan — do not regress)
</verification>

<success_criteria>
- ScrollScreen.tsx: refreshControl prop is typed and forwarded to ScrollView
- HeroCard.tsx: onExplorePress prop conditionally renders gold PrimaryButton labeled "Wander the Shop"
- SkeletonProductCard.tsx: new component exists, uses theme tokens only, matches ProductCard image height (160px)
- Zero new TypeScript errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/05-home-screen/05-01-SUMMARY.md` following the summary template at @/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</output>
