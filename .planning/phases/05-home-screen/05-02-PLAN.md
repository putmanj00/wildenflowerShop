---
phase: 05-home-screen
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - app/(tabs)/index.tsx
autonomous: true
requirements: [COMM-01]

must_haves:
  truths:
    - "Home screen fetches live Shopify products (featured collection, falling back to newest 6)"
    - "Products display in ProductGrid after type-adapting from AppProduct to Product"
    - "Skeleton cards (6 placeholders) show while products are loading"
    - "Brand-voiced error state shows when fetch fails, with a retry button"
    - "Pull-to-refresh triggers refetch on both hooks"
    - "Tapping a category chip navigates to Browse with that category as a URL param"
    - "HeroCard 'Wander the Shop' button navigates to Browse unfiltered"
    - "'See All' link on the Freshly Gathered section navigates to Browse unfiltered"
  artifacts:
    - path: "app/(tabs)/index.tsx"
      provides: "Fully wired Home screen with live Shopify data"
      contains: "mapAppProductToProduct"
    - path: "app/(tabs)/index.tsx"
      provides: "Featured collection fetch with allProducts fallback"
      contains: "useProducts.*featured"
    - path: "app/(tabs)/index.tsx"
      provides: "Pull-to-refresh wired via RefreshControl"
      contains: "RefreshControl"
  key_links:
    - from: "app/(tabs)/index.tsx"
      to: "hooks/useProducts"
      via: "useProducts({ collection: 'featured', limit: 6 })"
      pattern: "useProducts.*featured"
    - from: "app/(tabs)/index.tsx"
      to: "components/SkeletonProductCard"
      via: "isLoading conditional render"
      pattern: "isLoading.*SkeletonProductCard|SkeletonProductCard.*isLoading"
    - from: "app/(tabs)/index.tsx"
      to: "/(tabs)/browse"
      via: "router.push with category param"
      pattern: "router\\.push.*browse.*category"
---

<objective>
Wire the Home screen to live Shopify data. Replace mock data imports with useProducts hooks, add the AppProduct→Product type adapter, implement skeleton loading state, brand-voiced error state, pull-to-refresh, category navigation to Browse with params, and the HeroCard explore button.

Purpose: This is the primary deliverable for Phase 5 — the first real product-data screen in the app.
Output: A single updated file: `app/(tabs)/index.tsx` — fully wired Home screen.
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-home-screen/05-CONTEXT.md
@.planning/phases/05-home-screen/05-RESEARCH.md
@.planning/phases/05-home-screen/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Home screen to live Shopify data with loading, error, and pull-to-refresh</name>
  <files>app/(tabs)/index.tsx</files>
  <action>
Rewrite `app/(tabs)/index.tsx` completely. The file is currently 79 lines — the rewrite will be self-contained and comprehensive.

**Read the current file before editing.** Every element from the current layout must be preserved; only the data layer, state, and a few interaction handlers change.

**Step 1 — Imports**

Replace the mock-data and local state imports with the hook-based data layer. Final import block (following project import order from CONVENTIONS.md):

```typescript
import React from 'react';
import { View, Text, RefreshControl, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';

import { colors, copy, fonts, fontSizes, productCategories, spacing } from '../../constants/theme';
import { useFavorites } from '../../context/FavoritesContext';
import { useProducts } from '../../hooks/useProducts';
import type { AppProduct } from '../../lib/shopify-mappers';
import type { Product } from '../../types';

import ScrollScreen from '../../components/layout/ScrollScreen';
import BotanicalHeader from '../../components/BotanicalHeader';
import HeroCard from '../../components/HeroCard';
import SectionTitle from '../../components/SectionTitle';
import CategoryRow from '../../components/CategoryRow';
import BotanicalDivider from '../../components/BotanicalDivider';
import ProductGrid from '../../components/ProductGrid';
import SkeletonProductCard from '../../components/SkeletonProductCard';
import PrimaryButton from '../../components/PrimaryButton';
```

Remove: `import { useState } from 'react'`, `import { products } from '../../data/mock-data'`, and the `Product` type import (re-imported above).

**Step 2 — AppProduct → Product adapter (local, not exported)**

Place this pure function immediately before the `HomeScreen` component function:

```typescript
// ─── Local Type Adapter ──────────────────────────────────────────────────────
// Bridges AppProduct (Shopify shape) to Product (app UI shape).
// Screen-local until a future phase consolidates types.
function mapAppProductToProduct(p: AppProduct): Product {
  return {
    id: p.id,
    name: p.title,
    price: parseFloat(p.priceRange.minVariantPrice.amount),
    description: p.description,
    images: p.images.map((img) => img.url),
    category: p.productType || (p.tags[0] ?? ''),
    maker: {
      id: p.vendor.toLowerCase().replace(/\s+/g, '-'),
      name: p.vendor,
    },
    createdAt: new Date().toISOString(), // stub — not displayed on home screen
  };
}
```

**Step 3 — SkeletonGrid helper (local component)**

Place after the adapter, before `HomeScreen`:

```typescript
// ─── Skeleton Grid ───────────────────────────────────────────────────────────
// Six placeholder cards matching ProductGrid two-column layout.
function SkeletonGrid() {
  const left = [0, 2, 4];
  const right = [1, 3, 5];
  return (
    <View style={skeletonStyles.grid}>
      <View style={skeletonStyles.col}>
        {left.map((i) => (
          <SkeletonProductCard key={i} style={skeletonStyles.card} />
        ))}
      </View>
      <View style={skeletonStyles.col}>
        {right.map((i) => (
          <SkeletonProductCard key={i} style={skeletonStyles.card} />
        ))}
      </View>
    </View>
  );
}

const skeletonStyles = StyleSheet.create({
  grid: {
    flexDirection: 'row',
    paddingHorizontal: spacing.screenPadding,
    gap: spacing.itemGap,
  },
  col: {
    flex: 1,
  },
  card: {
    marginBottom: spacing.itemGap,
  },
});
```

**Step 4 — HomeScreen function body**

```typescript
export default function HomeScreen() {
  const router = useRouter();
  const { toggleFavorite, isFavorite } = useFavorites();

  // ─── Data ───────────────────────────────────────────────────────────────────
  // Try featured collection first; fall back to newest 6 if empty/missing.
  // Per CONTEXT.md: "Featured" collection handle; fallback to all products.
  // useProducts takes a plain options object — the hook stabilises the query fn internally.
  const featuredHook = useProducts({ collection: 'featured', limit: 6 });
  const allHook = useProducts({ limit: 6 });

  // ─── Derived state ───────────────────────────────────────────────────────────
  // Show skeleton only during the active hook's initial load.
  // Once featuredHook resolves: if empty, allHook becomes the data source.
  const useFeatured = !featuredHook.loading && featuredHook.products.length > 0;
  const activeHook = useFeatured ? featuredHook : allHook;
  const isLoading =
    featuredHook.loading ||
    (!featuredHook.loading && featuredHook.products.length === 0 && allHook.loading);
  const isRefreshing = featuredHook.isRefetching || allHook.isRefetching;
  const hasError = !isLoading && activeHook.error !== null;
  const displayProducts: Product[] = activeHook.products.map(mapAppProductToProduct);
  const favoritedIds = displayProducts.map((p) => p.id).filter((id) => isFavorite(id));

  // ─── Handlers ────────────────────────────────────────────────────────────────
  function handleProductPress(product: Product) {
    router.push(`/product/${product.id}`);
  }

  function handleCategoryPress(id: string) {
    // Navigate to Browse pre-filtered to the selected category.
    // Per CONTEXT.md: category id matches Shopify collection handle 1:1.
    // Browse (Phase 6) reads the param via useLocalSearchParams().
    router.push({
      pathname: '/(tabs)/browse',
      params: { category: id },
    });
  }

  function handleExplorePress() {
    router.push('/(tabs)/browse');
  }

  function handleRefresh() {
    featuredHook.refetch();
    allHook.refetch();
  }

  // ─── Render ──────────────────────────────────────────────────────────────────
  return (
    <ScrollScreen
      refreshControl={
        <RefreshControl
          refreshing={isRefreshing}
          onRefresh={handleRefresh}
          tintColor={colors.terracotta}
          colors={[colors.terracotta]}
        />
      }
    >
      <BotanicalHeader variant="large" />

      <HeroCard onExplorePress={handleExplorePress} />

      <SectionTitle title={copy.categories} />
      <CategoryRow
        categories={productCategories}
        activeCategory={null}
        onCategoryPress={handleCategoryPress}
      />

      <BotanicalDivider variant="fern-mushroom" />

      <SectionTitle
        title={copy.featured}
        action={{
          label: copy.viewAll,
          onPress: handleExplorePress,
        }}
      />

      {isLoading && <SkeletonGrid />}

      {hasError && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>
            The shop is resting.{'\n'}Try again soon.
          </Text>
          <PrimaryButton
            label="Try Again"
            onPress={handleRefresh}
            variant="terracotta"
          />
        </View>
      )}

      {!isLoading && !hasError && displayProducts.length === 0 && (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>
            Nothing here yet — but the best things take time.
          </Text>
        </View>
      )}

      {!isLoading && !hasError && displayProducts.length > 0 && (
        <ProductGrid
          products={displayProducts}
          onProductPress={handleProductPress}
          onFavoriteToggle={toggleFavorite}
          favorites={favoritedIds}
        />
      )}

    </ScrollScreen>
  );
}
```

**Step 5 — StyleSheet for error state**

```typescript
const styles = StyleSheet.create({
  errorContainer: {
    paddingHorizontal: spacing.screenPadding,
    paddingVertical: spacing.xxl,
    alignItems: 'center',
    gap: spacing.xl,
  },
  errorText: {
    fontFamily: fonts.accent,
    fontSize: fontSizes.bodyLarge,
    color: colors.sage,
    textAlign: 'center',
    lineHeight: fontSizes.bodyLarge * 1.6,
  },
  emptyContainer: {
    paddingHorizontal: spacing.screenPadding,
    paddingVertical: spacing.xxl,
    alignItems: 'center',
  },
  emptyText: {
    fontFamily: fonts.accent,
    fontSize: fontSizes.bodyLarge,
    color: colors.sage,
    textAlign: 'center',
    lineHeight: fontSizes.bodyLarge * 1.6,
  },
});
```

**useProducts hook signature (confirmed):**

`useProducts(options?: UseProductsOptions)` takes a plain object `{ collection?, limit? }`. It stabilises its own query function internally via `useCallback` on the destructured primitives. Do NOT wrap the call in `useCallback` on the screen side — pass a plain object literal directly. Do NOT change the hook.

**Anti-patterns to avoid (from RESEARCH.md):**
- Never pass `AppProduct[]` directly to `ProductGrid` — always apply `mapAppProductToProduct` first
- Never call `lib/shopify-client` directly — use `useProducts` hook only
- Never set `activeCategory` local state on category press — navigate to Browse instead
- `activeCategory={null}` always on Home screen (no local highlighting — navigation is instant)
  </action>
  <verify>
1. TypeScript: `npx tsc --noEmit` — zero new errors
2. Imports: `grep -n "mock-data\|useState" app/(tabs)/index.tsx` — neither should appear
3. Hooks: `grep -n "useProducts\|featured" app/(tabs)/index.tsx` — both hooks present
4. Adapter: `grep -n "mapAppProductToProduct" app/(tabs)/index.tsx` — function defined and called
5. Navigation: `grep -n "router.push.*browse" app/(tabs)/index.tsx` — at least 2 matches (category press + explore button)
6. RefreshControl: `grep -n "RefreshControl\|refreshControl" app/(tabs)/index.tsx` — both present
7. Skeleton: `grep -n "SkeletonProductCard\|isLoading" app/(tabs)/index.tsx` — both present
  </verify>
  <done>
- `app/(tabs)/index.tsx` no longer imports from `data/mock-data` or uses `useState` for activeCategory
- Two `useProducts` hooks called with plain option objects (not useCallback) provide featured-first-with-fallback pattern
- `mapAppProductToProduct` adapter bridges AppProduct to Product for ProductGrid
- SkeletonGrid renders 6 skeleton cards during initial load
- Brand-voiced error with terracotta "Try Again" button shows on fetch failure
- RefreshControl wired to both hooks' refetch()
- Category press navigates to `/(tabs)/browse` with `{ category: id }` param
- HeroCard receives `onExplorePress` prop; "See All" and HeroCard button both go to Browse unfiltered
  </done>
</task>

</tasks>

<verification>
Run from repo root after plan completes:
1. `npx tsc --noEmit` — zero new TypeScript errors
2. `grep -n "mock-data" app/(tabs)/index.tsx` — no match (mock data fully removed)
3. `grep -c "useProducts" app/(tabs)/index.tsx` — at least 2 (two hook calls)
4. `grep -n "mapAppProductToProduct" app/(tabs)/index.tsx` — function defined and applied to products
5. `grep -n "RefreshControl" app/(tabs)/index.tsx` — present in import and JSX
6. `grep -n "category.*id\|params.*category" app/(tabs)/index.tsx` — category param present in router.push
</verification>

<success_criteria>
- Home screen uses live Shopify data via useProducts (no mock data)
- ProductGrid receives Product[] after AppProduct→Product adapter applied
- Skeleton 6-card grid appears during initial load; disappears when data arrives
- Error state shows "The shop is resting. Try again soon." with retry button on fetch failure
- Pull-to-refresh indicator appears in terracotta; both hooks refetch on pull
- Category tap navigates to Browse with category param (not local state update)
- HeroCard "Wander the Shop" button navigates to Browse unfiltered
- "See All" link navigates to Browse unfiltered
- Zero new TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-home-screen/05-02-SUMMARY.md` following the summary template at @/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</output>
