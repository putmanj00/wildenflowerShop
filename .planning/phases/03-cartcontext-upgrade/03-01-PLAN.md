---
phase: 03-cartcontext-upgrade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types/shopify.ts
  - lib/shopify-queries.ts
  - lib/shopify-client.ts
autonomous: true
requirements:
  - SHOP-06

must_haves:
  truths:
    - "Five new named exports exist in lib/shopify-client.ts: createCart, getCart, addCartLines, removeCartLines, updateCartLines"
    - "Cart mutations and GET_CART_QUERY are exported from lib/shopify-queries.ts"
    - "CartLineSnapshot interface is exported from types/shopify.ts"
    - "CartUserError interface is exported from types/shopify.ts"
    - "All cart service functions are typed against ShopifyCart and CartLineSnapshot — no `any` types"
  artifacts:
    - path: "types/shopify.ts"
      provides: "CartLineSnapshot and CartUserError types"
      contains: "CartLineSnapshot"
    - path: "lib/shopify-queries.ts"
      provides: "CART_CREATE_MUTATION, CART_LINES_ADD_MUTATION, CART_LINES_REMOVE_MUTATION, CART_LINES_UPDATE_MUTATION, GET_CART_QUERY"
      exports:
        - CART_CREATE_MUTATION
        - CART_LINES_ADD_MUTATION
        - CART_LINES_REMOVE_MUTATION
        - CART_LINES_UPDATE_MUTATION
        - GET_CART_QUERY
    - path: "lib/shopify-client.ts"
      provides: "Cart service functions consumed by CartContext"
      exports:
        - createCart
        - getCart
        - addCartLines
        - removeCartLines
        - updateCartLines
  key_links:
    - from: "lib/shopify-client.ts"
      to: "lib/shopify-queries.ts"
      via: "named imports of cart mutation strings"
      pattern: "CART_CREATE_MUTATION|CART_LINES_ADD_MUTATION|GET_CART_QUERY"
    - from: "lib/shopify-client.ts"
      to: "types/shopify.ts"
      via: "ShopifyCart and CartLineSnapshot type imports"
      pattern: "import.*ShopifyCart.*CartLineSnapshot"
    - from: "lib/shopify-client.ts"
      to: "shopifyFetch (internal)"
      via: "direct call — shopifyFetch is not re-exported"
      pattern: "shopifyFetch<"
---

<objective>
Add Shopify cart GraphQL mutations, the cart query, and five typed service functions to the existing Shopify service layer.

Purpose: CartContext (Plan 03) consumes these service functions directly — this layer bridges the raw Shopify API to the context layer without the context needing to know any GraphQL.
Output: CartLineSnapshot type, CartUserError type, CART_LINES_FRAGMENT + five query/mutation strings, five exported async service functions.
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cartcontext-upgrade/03-RESEARCH.md
@lib/shopify-client.ts
@lib/shopify-queries.ts
@types/shopify.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CartLineSnapshot and CartUserError types to types/shopify.ts</name>
  <files>types/shopify.ts</files>
  <action>
Append two new exported interfaces to the bottom of types/shopify.ts, after ShopifyPaginatedResult:

```typescript
// Minimal snapshot stored in AsyncStorage for expired-cart recovery.
// Only { variantId, quantity } — never the full ShopifyCart (too large, immediately stale).
export interface CartLineSnapshot {
  variantId: string;   // gid://shopify/ProductVariant/...
  quantity: number;
}

// Shopify mutation user errors — returned in mutation response bodies alongside cart data.
// HTTP status is 200 even when userErrors is non-empty; check this field explicitly.
export interface CartUserError {
  code: string;
  field: string[] | null;
  message: string;
}
```

No changes to any existing type. These are additive.
  </action>
  <verify>
Run: `npx tsc --noEmit` from project root — zero new type errors.
Confirm: `grep -n "CartLineSnapshot\|CartUserError" types/shopify.ts` shows both interfaces defined and exported.
  </verify>
  <done>CartLineSnapshot and CartUserError are exported from types/shopify.ts; TypeScript compilation succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Add cart fragment, mutations, and GET_CART_QUERY to lib/shopify-queries.ts</name>
  <files>lib/shopify-queries.ts</files>
  <action>
Append to the end of lib/shopify-queries.ts, after the existing SEARCH_PRODUCTS_QUERY. Follow the exact naming and concatenation pattern already used in the file.

Add a private CART_LINES_FRAGMENT (not exported — embedded in each query via template literal interpolation), then five exports:

```typescript
// ─── Cart ─────────────────────────────────────────────────────────────────────
// Reusable fragment for all cart operations.
// nodes shorthand matches ShopifyCart type (lines: { nodes: ShopifyCartLine[] }).
// lines(first: 100) — safe upper bound; cartLinesRemove/Update require lineIds which
// come from the cart lines, so the entire list must be fetched.

const CART_LINES_FRAGMENT = `
  fragment CartLinesFragment on Cart {
    id
    checkoutUrl
    totalQuantity
    lines(first: 100) {
      nodes {
        id
        quantity
        merchandise {
          ... on ProductVariant {
            id
            title
            price { amount currencyCode }
            product {
              id
              title
              handle
              featuredImage { url altText width height }
            }
            selectedOptions { name value }
          }
        }
        cost {
          totalAmount { amount currencyCode }
        }
      }
    }
    cost {
      subtotalAmount { amount currencyCode }
      totalAmount { amount currencyCode }
      totalTaxAmount { amount currencyCode }
    }
  }
`;

export const CART_CREATE_MUTATION = `
  mutation CartCreate($lines: [CartLineInput!]) {
    cartCreate(input: { lines: $lines }) {
      cart { ...CartLinesFragment }
      userErrors { code field message }
    }
  }
  ${CART_LINES_FRAGMENT}
`;
// Variables: { lines: [{ merchandiseId: string, quantity: number }] }
// Empty cart: pass lines: [] or omit lines entirely

export const CART_LINES_ADD_MUTATION = `
  mutation CartLinesAdd($cartId: ID!, $lines: [CartLineInput!]!) {
    cartLinesAdd(cartId: $cartId, lines: $lines) {
      cart { ...CartLinesFragment }
      userErrors { code field message }
    }
  }
  ${CART_LINES_FRAGMENT}
`;
// Variables: { cartId: string, lines: [{ merchandiseId: string, quantity: number }] }

export const CART_LINES_REMOVE_MUTATION = `
  mutation CartLinesRemove($cartId: ID!, $lineIds: [ID!]!) {
    cartLinesRemove(cartId: $cartId, lineIds: $lineIds) {
      cart { ...CartLinesFragment }
      userErrors { code field message }
    }
  }
  ${CART_LINES_FRAGMENT}
`;
// Variables: { cartId: string, lineIds: [CartLine.id, ...] }
// IMPORTANT: lineIds is CartLine.id (gid://shopify/CartLine/...) NOT merchandise.id (variantId)

export const CART_LINES_UPDATE_MUTATION = `
  mutation CartLinesUpdate($cartId: ID!, $lines: [CartLineUpdateInput!]!) {
    cartLinesUpdate(cartId: $cartId, lines: $lines) {
      cart { ...CartLinesFragment }
      userErrors { code field message }
    }
  }
  ${CART_LINES_FRAGMENT}
`;
// Variables: { cartId: string, lines: [{ id: CartLine.id, quantity: number }] }
// Do NOT call with quantity: 0 — call cartLinesRemove instead (cartLinesUpdate may error)

export const GET_CART_QUERY = `
  query GetCart($cartId: ID!) {
    cart(id: $cartId) {
      ...CartLinesFragment
    }
  }
  ${CART_LINES_FRAGMENT}
`;
// Returns: { cart: ShopifyCart } or { cart: null } when cart is expired/not found.
// null is NOT a GraphQL error — check data.cart === null to trigger recovery.
```
  </action>
  <verify>
Run: `npx tsc --noEmit` — zero new errors.
Run: `grep -n "export const CART_CREATE_MUTATION\|CART_LINES_ADD_MUTATION\|CART_LINES_REMOVE_MUTATION\|CART_LINES_UPDATE_MUTATION\|GET_CART_QUERY" lib/shopify-queries.ts` — all five exports present.
  </verify>
  <done>Five cart query/mutation strings are exported from lib/shopify-queries.ts; file compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 3: Add cart service functions to lib/shopify-client.ts</name>
  <files>lib/shopify-client.ts</files>
  <action>
Add five new exported async service functions to lib/shopify-client.ts. Follow the exact pattern of the existing five service functions (typed return, shopifyFetch call, named exports only — shopifyFetch stays private).

Step 1: Add new imports at the top of the existing import block:
- Add `ShopifyCart, CartLineSnapshot, CartUserError` to the existing `import type { ... } from '../types/shopify'` statement.
- Add `CART_CREATE_MUTATION, CART_LINES_ADD_MUTATION, CART_LINES_REMOVE_MUTATION, CART_LINES_UPDATE_MUTATION, GET_CART_QUERY` to the existing `import { ... } from './shopify-queries'` statement.

Step 2: Append the following five functions at the bottom of the file, after `searchProducts`, in a new `// ─── Cart Service Functions ───` section:

```typescript
// ─── Cart Service Functions ───────────────────────────────────────────────────
// These are the only Shopify cart API surface exposed to CartContext.
// shopifyFetch stays private; only named service functions are exported.

/**
 * Creates a new Shopify cart.
 * Pass lines to pre-populate (used during expired-cart recovery); omit for empty cart.
 * Throws ShopifyError if cartCreate returns userErrors.
 */
export async function createCart(lines: CartLineSnapshot[] = []): Promise<ShopifyCart> {
  const data = await shopifyFetch<{
    cartCreate: { cart: ShopifyCart; userErrors: CartUserError[] };
  }>(CART_CREATE_MUTATION, {
    lines: lines.map((l) => ({ merchandiseId: l.variantId, quantity: l.quantity })),
  });
  if (data.cartCreate.userErrors.length > 0) {
    throw new ShopifyError(
      data.cartCreate.userErrors.map((e) => e.message).join('; '),
      200,
      CART_CREATE_MUTATION,
      STORE_DOMAIN
    );
  }
  return data.cartCreate.cart;
}

/**
 * Fetches the current state of an existing cart.
 * Returns null if the cart is expired or not found — NOT an error; triggers recovery in CartContext.
 */
export async function getCart(cartId: string): Promise<ShopifyCart | null> {
  const data = await shopifyFetch<{ cart: ShopifyCart | null }>(GET_CART_QUERY, { cartId });
  return data.cart;
}

/**
 * Adds one or more lines to an existing cart.
 * Each line: { variantId: gid://shopify/ProductVariant/..., quantity: number }
 * Throws ShopifyError if cartLinesAdd returns userErrors.
 */
export async function addCartLines(
  cartId: string,
  lines: CartLineSnapshot[]
): Promise<ShopifyCart> {
  const data = await shopifyFetch<{
    cartLinesAdd: { cart: ShopifyCart; userErrors: CartUserError[] };
  }>(CART_LINES_ADD_MUTATION, {
    cartId,
    lines: lines.map((l) => ({ merchandiseId: l.variantId, quantity: l.quantity })),
  });
  if (data.cartLinesAdd.userErrors.length > 0) {
    throw new ShopifyError(
      data.cartLinesAdd.userErrors.map((e) => e.message).join('; '),
      200,
      CART_LINES_ADD_MUTATION,
      STORE_DOMAIN
    );
  }
  return data.cartLinesAdd.cart;
}

/**
 * Removes lines from an existing cart.
 * lineIds: CartLine.id values (gid://shopify/CartLine/...) — NOT variantIds.
 * Throws ShopifyError if cartLinesRemove returns userErrors.
 */
export async function removeCartLines(
  cartId: string,
  lineIds: string[]
): Promise<ShopifyCart> {
  const data = await shopifyFetch<{
    cartLinesRemove: { cart: ShopifyCart; userErrors: CartUserError[] };
  }>(CART_LINES_REMOVE_MUTATION, { cartId, lineIds });
  if (data.cartLinesRemove.userErrors.length > 0) {
    throw new ShopifyError(
      data.cartLinesRemove.userErrors.map((e) => e.message).join('; '),
      200,
      CART_LINES_REMOVE_MUTATION,
      STORE_DOMAIN
    );
  }
  return data.cartLinesRemove.cart;
}

/**
 * Updates quantities of existing cart lines.
 * lines: [{ id: CartLine.id, quantity: number }] — NOT variantIds.
 * Do NOT pass quantity: 0 here; call removeCartLines instead to avoid INVALID user error.
 * Throws ShopifyError if cartLinesUpdate returns userErrors.
 */
export async function updateCartLines(
  cartId: string,
  lines: Array<{ id: string; quantity: number }>
): Promise<ShopifyCart> {
  const data = await shopifyFetch<{
    cartLinesUpdate: { cart: ShopifyCart; userErrors: CartUserError[] };
  }>(CART_LINES_UPDATE_MUTATION, { cartId, lines });
  if (data.cartLinesUpdate.userErrors.length > 0) {
    throw new ShopifyError(
      data.cartLinesUpdate.userErrors.map((e) => e.message).join('; '),
      200,
      CART_LINES_UPDATE_MUTATION,
      STORE_DOMAIN
    );
  }
  return data.cartLinesUpdate.cart;
}
```

Note: `STORE_DOMAIN` is already defined at the top of the file as a module-level constant — pass it to ShopifyError for consistent error messages.
  </action>
  <verify>
Run: `npx tsc --noEmit` — zero new errors.
Run: `node -e "const m = require('./lib/shopify-client.ts')"` (or TypeScript check) to verify exports.
Run: `grep -n "export async function" lib/shopify-client.ts` — should show: getProducts, getProductByHandle, getCollections, getCollectionByHandle, searchProducts, createCart, getCart, addCartLines, removeCartLines, updateCartLines (10 total).
  </verify>
  <done>Five cart service functions are exported from lib/shopify-client.ts; TypeScript compiles without errors; all ten service functions present.</done>
</task>

</tasks>

<verification>
After all three tasks:
1. `npx tsc --noEmit` passes with zero errors
2. `grep -c "export" lib/shopify-queries.ts` returns at least 10 (existing 5 + new 5)
3. `grep -c "export async function" lib/shopify-client.ts` returns 10
4. `grep "CartLineSnapshot\|CartUserError" types/shopify.ts` shows both defined and exported
</verification>

<success_criteria>
- types/shopify.ts exports CartLineSnapshot and CartUserError interfaces
- lib/shopify-queries.ts exports CART_CREATE_MUTATION, CART_LINES_ADD_MUTATION, CART_LINES_REMOVE_MUTATION, CART_LINES_UPDATE_MUTATION, GET_CART_QUERY
- lib/shopify-client.ts exports createCart, getCart, addCartLines, removeCartLines, updateCartLines
- Zero TypeScript errors
- shopifyFetch remains private (not exported)
- Each cart service function throws ShopifyError on userErrors, not on null cart (getCart returns null for expired carts)
</success_criteria>

<output>
After completion, create `.planning/phases/03-cartcontext-upgrade/03-01-SUMMARY.md`
</output>
