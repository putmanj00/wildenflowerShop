---
phase: 03-cartcontext-upgrade
plan: 03
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - context/CartContext.tsx
autonomous: true
requirements:
  - SHOP-06
  - SHOP-07

must_haves:
  truths:
    - "CartContext exports cartId, cart, isLoading, isAddingToCart, isRemovingFromCart, isUpdatingQuantity, addToCart, removeFromCart, updateQuantity, clearCart, cartCount, cartTotal"
    - "addToCart(variantId, quantity?) calls Shopify cartLinesAdd (or cartCreate if no cart exists) and returns Promise<boolean>"
    - "removeFromCart(lineId) calls Shopify cartLinesRemove with the CartLine.id and returns Promise<boolean>"
    - "updateQuantity(lineId, quantity) calls cartLinesRemove when quantity <= 0, else cartLinesUpdate — returns Promise<boolean>"
    - "On app start with no stored cart ID, CartContext exposes isLoading: false, cart: null immediately"
    - "On app start with a valid stored cart ID, CartContext re-hydrates the cart from Shopify before setting isLoading: false"
    - "On app start with an expired cart ID (Shopify returns null), CartContext silently creates a new cart from the stored snapshot"
    - "If recovery fails, CartContext clears AsyncStorage and exposes empty cart — no error surfaced to user"
    - "On mutation failure, cart state rolls back to pre-mutation state — no optimistic updates"
    - "cartTotal derived from cart.cost.subtotalAmount; cartCount from cart.totalQuantity"
    - "CartContext does NOT manage favorites — no favorites state, no toggleFavorite, no isFavorite"
    - "Old Product-based addToCart(product: Product) API is removed — new signature is addToCart(variantId: string, quantity?: number)"
  artifacts:
    - path: "context/CartContext.tsx"
      provides: "Shopify-backed cart with AsyncStorage persistence"
      exports:
        - CartProvider
        - useCart
      min_lines: 150
  key_links:
    - from: "context/CartContext.tsx"
      to: "lib/shopify-client.ts"
      via: "import createCart, getCart, addCartLines, removeCartLines, updateCartLines"
      pattern: "import.*createCart.*getCart"
    - from: "context/CartContext.tsx"
      to: "@react-native-async-storage/async-storage"
      via: "AsyncStorage.getItem / setItem / multiRemove"
      pattern: "AsyncStorage\\.getItem|AsyncStorage\\.setItem"
    - from: "context/CartContext.tsx"
      to: "types/shopify.ts"
      via: "ShopifyCart, CartLineSnapshot types"
      pattern: "import.*ShopifyCart.*CartLineSnapshot|import.*CartLineSnapshot"
---

<objective>
Rewrite context/CartContext.tsx to replace the mock useReducer implementation with a real Shopify cart backed by GraphQL mutations and AsyncStorage persistence.

Purpose: This is the core deliverable of Phase 3. CartContext becomes the live bridge between the app UI and Shopify's cart API. All screens that will eventually call addToCart, removeFromCart, and updateQuantity will consume this context.
Output: context/CartContext.tsx fully rewritten — Shopify-backed, AsyncStorage-persisted, typed against types/shopify.ts, with favorites removed (now in FavoritesContext from Plan 02).
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cartcontext-upgrade/03-CONTEXT.md
@.planning/phases/03-cartcontext-upgrade/03-RESEARCH.md
@.planning/phases/03-cartcontext-upgrade/03-01-SUMMARY.md
@context/CartContext.tsx
@types/shopify.ts
@lib/shopify-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite context/CartContext.tsx with Shopify mutations and AsyncStorage hydration</name>
  <files>context/CartContext.tsx</files>
  <action>
Fully replace context/CartContext.tsx. The old useReducer + Product-based implementation is removed entirely. Write fresh from scratch using the locked decisions in CONTEXT.md and the patterns in RESEARCH.md.

**CRITICAL locked decisions to honor (from CONTEXT.md):**
- `addToCart(variantId: string, quantity?: number)` — NOT `addToCart(product: Product)` — the old API is intentionally broken
- Both top-level `isLoading` AND per-operation flags: `isAddingToCart`, `isRemovingFromCart`, `isUpdatingQuantity`
- Mutations return `Promise<boolean>` (true = success, false = failure; no throw from context layer)
- No persistent error state on context — screens handle errors from the boolean return
- No optimistic updates — roll back to previous state on failure
- On failure, roll back cart state to pre-mutation values
- Expired cart recovery: silent, blocking (isLoading: true throughout), re-adds snapshot lines
- Recovery failure: clear AsyncStorage, expose empty cart, no error
- `cartTotal` from `cart?.cost?.subtotalAmount.amount` (parseFloat); `cartCount` from `cart?.totalQuantity ?? 0`
- NO favorites — favorites are in FavoritesContext now

**AsyncStorage keys (Claude's discretion — use these):**
```typescript
const STORAGE_CART_ID = '@wildenflower/cart_id';
const STORAGE_CART_SNAPSHOT = '@wildenflower/cart_snapshot';
```

**Full implementation structure:**

```typescript
/**
 * Wildenflower — Cart Context
 * ============================
 * Shopify-backed cart state using cartCreate/cartLinesAdd/cartLinesRemove/cartLinesUpdate.
 * Cart ID and line snapshot persisted to AsyncStorage for cross-session continuity.
 * Favorites are managed separately in FavoritesContext.
 */

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import type { ShopifyCart, CartLineSnapshot } from '../types/shopify';
import {
  createCart,
  getCart,
  addCartLines,
  removeCartLines,
  updateCartLines,
} from '../lib/shopify-client';

// ─── AsyncStorage Keys ───────────────────────────────────────────────────────

const STORAGE_CART_ID = '@wildenflower/cart_id';
const STORAGE_CART_SNAPSHOT = '@wildenflower/cart_snapshot';

// ─── Context Type ────────────────────────────────────────────────────────────

interface CartContextType {
  // Data
  cartId: string | null;
  cart: ShopifyCart | null;
  // Loading flags
  isLoading: boolean;           // true during hydration or any in-flight mutation
  isAddingToCart: boolean;
  isRemovingFromCart: boolean;
  isUpdatingQuantity: boolean;
  // Mutations — return true on success, false on failure (no throw from context layer)
  addToCart: (variantId: string, quantity?: number) => Promise<boolean>;
  removeFromCart: (lineId: string) => Promise<boolean>;
  updateQuantity: (lineId: string, quantity: number) => Promise<boolean>;
  clearCart: () => Promise<void>;
  // Derived
  cartCount: number;
  cartTotal: number;
}

// ─── Context ─────────────────────────────────────────────────────────────────

const CartContext = createContext<CartContextType | undefined>(undefined);

// ─── Helpers ─────────────────────────────────────────────────────────────────

/** Extracts a line snapshot from a live cart for AsyncStorage persistence */
function buildSnapshot(cart: ShopifyCart): CartLineSnapshot[] {
  return cart.lines.nodes.map((line) => ({
    variantId: line.merchandise.id,
    quantity: line.quantity,
  }));
}

/** Persists cart ID and line snapshot to AsyncStorage after every successful mutation */
async function persistCart(cart: ShopifyCart): Promise<void> {
  const snapshot = buildSnapshot(cart);
  await Promise.all([
    AsyncStorage.setItem(STORAGE_CART_ID, cart.id),
    AsyncStorage.setItem(STORAGE_CART_SNAPSHOT, JSON.stringify(snapshot)),
  ]);
}

// ─── Provider ────────────────────────────────────────────────────────────────

export const CartProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [cartId, setCartId] = useState<string | null>(null);
  const [cart, setCart] = useState<ShopifyCart | null>(null);
  const [isLoading, setIsLoading] = useState(true); // true until hydration completes
  const [isAddingToCart, setIsAddingToCart] = useState(false);
  const [isRemovingFromCart, setIsRemovingFromCart] = useState(false);
  const [isUpdatingQuantity, setIsUpdatingQuantity] = useState(false);

  // ─── Startup Hydration ─────────────────────────────────────────────────────

  useEffect(() => {
    let cancelled = false;

    async function hydrate() {
      setIsLoading(true);
      try {
        const [storedId, storedSnapshotRaw] = await Promise.all([
          AsyncStorage.getItem(STORAGE_CART_ID),
          AsyncStorage.getItem(STORAGE_CART_SNAPSHOT),
        ]);

        if (!storedId) {
          // No persisted cart — start fresh immediately
          if (!cancelled) setIsLoading(false);
          return;
        }

        const snapshot: CartLineSnapshot[] = storedSnapshotRaw
          ? JSON.parse(storedSnapshotRaw)
          : [];

        const existingCart = await getCart(storedId);

        if (cancelled) return;

        if (existingCart) {
          // Cart is alive — use it
          setCartId(existingCart.id);
          setCart(existingCart);
        } else {
          // Cart expired (Shopify returned null) — silent recovery
          try {
            const newCart = await createCart(snapshot);
            if (!cancelled) {
              await persistCart(newCart);
              setCartId(newCart.id);
              setCart(newCart);
            }
          } catch {
            // Recovery failed — start fresh, clear storage, no error surfaced
            await AsyncStorage.multiRemove([STORAGE_CART_ID, STORAGE_CART_SNAPSHOT]).catch(() => {});
            if (!cancelled) {
              setCartId(null);
              setCart(null);
            }
          }
        }
      } catch {
        // AsyncStorage read failed — start with empty cart, don't crash
        if (!cancelled) {
          setCartId(null);
          setCart(null);
        }
      } finally {
        if (!cancelled) setIsLoading(false);
      }
    }

    hydrate();
    return () => { cancelled = true; };
  }, []);

  // ─── Mutations ────────────────────────────────────────────────────────────

  const addToCart = async (variantId: string, quantity: number = 1): Promise<boolean> => {
    setIsAddingToCart(true);
    setIsLoading(true);
    const previousCart = cart;
    const previousCartId = cartId;
    try {
      let newCart: ShopifyCart;
      if (cartId) {
        newCart = await addCartLines(cartId, [{ variantId, quantity }]);
      } else {
        // No cart yet — create one with this first line
        newCart = await createCart([{ variantId, quantity }]);
      }
      await persistCart(newCart);
      setCartId(newCart.id);
      setCart(newCart);
      return true;
    } catch {
      // Rollback — restore previous state (no optimistic update to undo)
      setCartId(previousCartId);
      setCart(previousCart);
      return false;
    } finally {
      setIsAddingToCart(false);
      setIsLoading(false);
    }
  };

  const removeFromCart = async (lineId: string): Promise<boolean> => {
    if (!cartId) return false;
    setIsRemovingFromCart(true);
    setIsLoading(true);
    const previousCart = cart;
    try {
      const newCart = await removeCartLines(cartId, [lineId]);
      await persistCart(newCart);
      setCart(newCart);
      return true;
    } catch {
      setCart(previousCart);
      return false;
    } finally {
      setIsRemovingFromCart(false);
      setIsLoading(false);
    }
  };

  const updateQuantity = async (lineId: string, quantity: number): Promise<boolean> => {
    if (!cartId) return false;
    setIsUpdatingQuantity(true);
    setIsLoading(true);
    const previousCart = cart;
    try {
      let newCart: ShopifyCart;
      if (quantity <= 0) {
        // cartLinesUpdate with quantity: 0 may produce INVALID error — remove instead
        newCart = await removeCartLines(cartId, [lineId]);
      } else {
        newCart = await updateCartLines(cartId, [{ id: lineId, quantity }]);
      }
      await persistCart(newCart);
      setCart(newCart);
      return true;
    } catch {
      setCart(previousCart);
      return false;
    } finally {
      setIsUpdatingQuantity(false);
      setIsLoading(false);
    }
  };

  const clearCart = async (): Promise<void> => {
    setIsLoading(true);
    try {
      await AsyncStorage.multiRemove([STORAGE_CART_ID, STORAGE_CART_SNAPSHOT]).catch(() => {});
      setCartId(null);
      setCart(null);
    } finally {
      setIsLoading(false);
    }
  };

  // ─── Derived Values ───────────────────────────────────────────────────────

  const cartCount = cart?.totalQuantity ?? 0;
  const cartTotal = cart?.cost?.subtotalAmount
    ? parseFloat(cart.cost.subtotalAmount.amount)
    : 0;

  return (
    <CartContext.Provider
      value={{
        cartId,
        cart,
        isLoading,
        isAddingToCart,
        isRemovingFromCart,
        isUpdatingQuantity,
        addToCart,
        removeFromCart,
        updateQuantity,
        clearCart,
        cartCount,
        cartTotal,
      }}
    >
      {children}
    </CartContext.Provider>
  );
};

// ─── Hook ────────────────────────────────────────────────────────────────────

export const useCart = (): CartContextType => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};
```

**Anti-patterns to avoid (from RESEARCH.md):**
- Do NOT expose `state` object — old CartContext exposed `state: CartState`. New API has explicit fields.
- Do NOT export `toggleFavorite` or `isFavorite` — those are in FavoritesContext now.
- Do NOT pass `product: Product` to addToCart — the new API takes `variantId: string`.
- Do NOT call cartLinesUpdate with quantity: 0 — route to removeCartLines instead (handled in updateQuantity above).
- Do NOT use edges/node notation in queries — use nodes shorthand (already done in shopify-queries.ts from Plan 01).
  </action>
  <verify>
Run: `npx tsc --noEmit` — zero TypeScript errors.
Run: `grep -n "product: Product\|state: CartState\|toggleFavorite\|isFavorite\|useReducer" context/CartContext.tsx` — empty result (old API fully removed).
Run: `grep -n "isAddingToCart\|isRemovingFromCart\|isUpdatingQuantity\|STORAGE_CART_ID\|STORAGE_CART_SNAPSHOT" context/CartContext.tsx` — all present.
Run: `grep -n "export" context/CartContext.tsx` — shows CartProvider and useCart (only two exports).
  </verify>
  <done>
context/CartContext.tsx is fully rewritten:
- CartProvider and useCart are the only exports
- addToCart(variantId, quantity?) — new API, no Product type
- All five loading flags present
- AsyncStorage hydration with expired-cart recovery
- cartTotal from subtotalAmount, cartCount from totalQuantity
- No favorites state
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After task completion:
1. `npx tsc --noEmit` — zero errors
2. `grep "toggleFavorite\|isFavorite\|product: Product\|useReducer" context/CartContext.tsx` — empty (old API gone)
3. `grep "isAddingToCart\|isRemovingFromCart\|isUpdatingQuantity" context/CartContext.tsx` — all three present
4. `grep "STORAGE_CART_ID\|STORAGE_CART_SNAPSHOT" context/CartContext.tsx` — both keys defined
5. `grep "addToCart\|removeFromCart\|updateQuantity\|clearCart" context/CartContext.tsx` — all four mutation functions present
6. `grep "CartLineSnapshot\|ShopifyCart" context/CartContext.tsx` — types imported from types/shopify.ts
7. `grep "createCart\|getCart\|addCartLines\|removeCartLines\|updateCartLines" context/CartContext.tsx` — all five service functions imported
8. Screens that call useCart still compile: `npx tsc --noEmit` catches any call sites using the old Product API
</verification>

<success_criteria>
- CartContext rewritten with Shopify cart mutations — no mock data, no useReducer
- addToCart(variantId, quantity?) is the public API — old addToCart(product) is gone
- AsyncStorage persists cart ID and line snapshot after every mutation
- Hydration on startup: loads existing cart or recovers from expiry silently
- Mutation failures roll back state — no optimistic updates
- updateQuantity routes quantity <= 0 to removeCartLines
- cartCount = cart.totalQuantity, cartTotal = parseFloat(cart.cost.subtotalAmount.amount)
- No favorites state in CartContext
- TypeScript compiles clean (including any screens that import useCart)
</success_criteria>

<output>
After completion, create `.planning/phases/03-cartcontext-upgrade/03-03-SUMMARY.md`
</output>
