---
phase: 03-cartcontext-upgrade
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - context/FavoritesContext.tsx
  - app/_layout.tsx
autonomous: true
requirements:
  - SHOP-06

must_haves:
  truths:
    - "FavoritesContext.tsx exists and exports useFavorites hook and FavoritesProvider component"
    - "useFavorites returns favorites (string[]), toggleFavorite, and isFavorite"
    - "FavoritesProvider wraps CartProvider in app/_layout.tsx"
    - "app/_layout.tsx still compiles and the CartProvider key={retryKey} pattern is preserved"
    - "favorites state is memory-only — no AsyncStorage import in FavoritesContext.tsx"
  artifacts:
    - path: "context/FavoritesContext.tsx"
      provides: "Memory-only favorites state (extract from CartContext)"
      exports:
        - FavoritesProvider
        - useFavorites
    - path: "app/_layout.tsx"
      provides: "Updated provider nesting — FavoritesProvider inside CartProvider"
      contains: "FavoritesProvider"
  key_links:
    - from: "app/_layout.tsx"
      to: "context/FavoritesContext.tsx"
      via: "import FavoritesProvider"
      pattern: "import.*FavoritesProvider"
    - from: "context/FavoritesContext.tsx"
      to: "React"
      via: "createContext, useState, useContext"
      pattern: "createContext|useState|useContext"
---

<objective>
Extract favorites state out of CartContext into a new memory-only FavoritesContext, and wire FavoritesProvider into the root layout.

Purpose: The locked decision (CONTEXT.md) requires favorites to live in their own context. Phase 8 will add AsyncStorage persistence to FavoritesContext — this plan creates the clean receptacle. CartContext rewrite (Plan 03) will not need to manage favorites state at all.
Output: context/FavoritesContext.tsx (new), app/_layout.tsx (updated).
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cartcontext-upgrade/03-CONTEXT.md
@context/CartContext.tsx
@app/_layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context/FavoritesContext.tsx (memory-only favorites)</name>
  <files>context/FavoritesContext.tsx</files>
  <action>
Create context/FavoritesContext.tsx as a new file. This is a net-new file — favorites are being extracted FROM CartContext but FavoritesContext is written fresh (not a copy-paste).

Requirements from CONTEXT.md (locked):
- Memory-only — NO AsyncStorage import, NO persistence (Phase 8 adds that)
- Favorites stored as string[] of product IDs (same shape as old CartContext.favorites)
- Expose: favorites, toggleFavorite(id: string), isFavorite(id: string) => boolean

File content:

```typescript
/**
 * Wildenflower — Favorites Context
 * ==================================
 * Memory-only favorites state. Product IDs are stored in a string array.
 *
 * Persistence (AsyncStorage) is intentionally deferred to Phase 8.
 * FavoritesContext is separate from CartContext — they are independent concerns.
 */

import React, { createContext, useContext, useState, ReactNode } from 'react';

// ─── Types ───────────────────────────────────────────────────────────────────

interface FavoritesContextType {
  /** Product IDs currently favorited (memory-only, resets on app restart until Phase 8) */
  favorites: string[];
  /** Toggle a product ID in or out of favorites */
  toggleFavorite: (productId: string) => void;
  /** Returns true if the given product ID is currently favorited */
  isFavorite: (productId: string) => boolean;
}

// ─── Context ─────────────────────────────────────────────────────────────────

const FavoritesContext = createContext<FavoritesContextType | undefined>(undefined);

// ─── Provider ────────────────────────────────────────────────────────────────

export const FavoritesProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [favorites, setFavorites] = useState<string[]>([]);

  const toggleFavorite = (productId: string) => {
    setFavorites((prev) =>
      prev.includes(productId)
        ? prev.filter((id) => id !== productId)
        : [...prev, productId]
    );
  };

  const isFavorite = (productId: string): boolean => favorites.includes(productId);

  return (
    <FavoritesContext.Provider value={{ favorites, toggleFavorite, isFavorite }}>
      {children}
    </FavoritesContext.Provider>
  );
};

// ─── Hook ────────────────────────────────────────────────────────────────────

export const useFavorites = (): FavoritesContextType => {
  const context = useContext(FavoritesContext);
  if (!context) {
    throw new Error('useFavorites must be used within a FavoritesProvider');
  }
  return context;
};
```
  </action>
  <verify>
Run: `npx tsc --noEmit` — zero errors.
Confirm: `ls context/FavoritesContext.tsx` — file exists.
Confirm: No AsyncStorage import in the file: `grep "AsyncStorage" context/FavoritesContext.tsx` — empty result.
  </verify>
  <done>FavoritesContext.tsx exists, exports FavoritesProvider and useFavorites, has no AsyncStorage dependency, compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire FavoritesProvider into app/_layout.tsx</name>
  <files>app/_layout.tsx</files>
  <action>
Update app/_layout.tsx to import FavoritesProvider and nest it inside CartProvider.

CONTEXT.md locked decision for nesting order:
```tsx
<CartProvider key={retryKey}>
  <FavoritesProvider>
    <Stack ...>
```

FavoritesProvider is inside CartProvider (either order works since they're independent, but this matches the research pattern).

Changes needed:
1. Add import: `import { FavoritesProvider } from '../context/FavoritesContext';`
2. Wrap the `<Stack ...>` element with `<FavoritesProvider>...</FavoritesProvider>` inside the existing `<CartProvider key={retryKey}>` block.

The key={retryKey} must remain on CartProvider — do not move it.

The final JSX tree inside the font-success branch should be:
```tsx
<CartProvider key={retryKey}>
  <FavoritesProvider>
    <Stack
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: colors.parchment },
        animation: 'fade',
      }}
    >
      <Stack.Screen name="(tabs)" />
      <Stack.Screen name="product/[id]" />
      <Stack.Screen name="blog/index" />
      <Stack.Screen name="blog/[id]" />
      <Stack.Screen name="maker/[id]" />
      <Stack.Screen name="checkout" />
      <Stack.Screen name="about" />
      <Stack.Screen name="faq" />
    </Stack>
  </FavoritesProvider>
</CartProvider>
```

All other parts of _layout.tsx (font loading logic, SplashScreen, FontErrorScreen, retryKey state, handleRetry) remain unchanged.
  </action>
  <verify>
Run: `npx tsc --noEmit` — zero errors.
Run: `grep "FavoritesProvider" app/_layout.tsx` — shows both import and JSX usage.
Run: `grep "key={retryKey}" app/_layout.tsx` — still on CartProvider.
  </verify>
  <done>app/_layout.tsx imports FavoritesProvider, wraps Stack in FavoritesProvider inside CartProvider, key={retryKey} preserved, compiles without errors.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` passes
2. `ls context/FavoritesContext.tsx` — file exists
3. `grep "FavoritesProvider" app/_layout.tsx` — import and JSX both present
4. `grep "AsyncStorage" context/FavoritesContext.tsx` — empty (no persistence yet)
5. `grep "useFavorites\|FavoritesProvider" context/FavoritesContext.tsx` — both exports present
</verification>

<success_criteria>
- context/FavoritesContext.tsx is created with FavoritesProvider and useFavorites exports
- favorites is string[], memory-only, no AsyncStorage
- FavoritesProvider wraps Stack inside CartProvider in app/_layout.tsx
- key={retryKey} pattern unchanged on CartProvider
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-cartcontext-upgrade/03-02-SUMMARY.md`
</output>
