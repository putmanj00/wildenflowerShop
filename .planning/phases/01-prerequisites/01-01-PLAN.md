---
phase: 01-prerequisites
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/_layout.tsx
  - components/layout/FontErrorScreen.tsx
autonomous: true
requirements:
  - ASSET-01

must_haves:
  truths:
    - "App boots cleanly when fonts load successfully — splash screen hides and the app renders normally"
    - "App does NOT freeze when fonts fail — splash screen hides and FontErrorScreen is shown"
    - "FontErrorScreen is on-brand: warm Wildenflower voice, parchment background, single retry button, no custom fonts"
    - "Retry button triggers a font reload attempt — on web via window.location.reload(), on native via key-reset remount"
  artifacts:
    - path: "app/_layout.tsx"
      provides: "Root layout with correct font error handling"
      contains: "const [fontsLoaded, fontError] = useFonts"
    - path: "components/layout/FontErrorScreen.tsx"
      provides: "On-brand error screen shown when fonts fail to load"
      min_lines: 40
  key_links:
    - from: "app/_layout.tsx"
      to: "components/layout/FontErrorScreen.tsx"
      via: "conditional render when fontError is truthy"
      pattern: "fontError.*FontErrorScreen|FontErrorScreen.*fontError"
    - from: "app/_layout.tsx"
      to: "expo-splash-screen SplashScreen.hideAsync()"
      via: "useEffect that fires when fontsLoaded OR fontError is truthy"
      pattern: "fontsLoaded.*fontError.*hideAsync|fontError.*fontsLoaded.*hideAsync"
---

<objective>
Fix the font loading freeze bug in the root layout and create an on-brand font error screen.

Purpose: The current `app/_layout.tsx` only checks `fontsLoaded` — if fonts fail (network error, missing file), `fontsLoaded` stays false forever, `SplashScreen.hideAsync()` is never called, and the app appears frozen as a blank parchment rectangle with no escape. This is a confirmed bug in the existing code.

Output: A fixed `_layout.tsx` that handles both success and failure, plus a `FontErrorScreen` component that displays a warm Wildenflower error message with a retry button.
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/01-prerequisites/01-RESEARCH.md
@app/_layout.tsx
@constants/theme.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix font error handling in root layout</name>
  <files>app/_layout.tsx</files>
  <action>
Update `app/_layout.tsx` to handle the font error case correctly.

Current bug: `const [fontsLoaded] = useFonts(...)` — only one value destructured. If fonts fail, `fontsLoaded` is always false, `SplashScreen.hideAsync()` never fires, app freezes.

Changes to make:

1. Destructure both values: `const [fontsLoaded, fontError] = useFonts({ ... })`

2. Add a `retryKey` state for the native retry mechanism:
   ```tsx
   const [retryKey, setRetryKey] = React.useState(0);
   ```

3. Update the `useEffect` to fire on either condition:
   ```tsx
   useEffect(() => {
     if (fontsLoaded || fontError) {
       SplashScreen.hideAsync();
     }
   }, [fontsLoaded, fontError]);
   ```

4. Update the early return guard:
   ```tsx
   if (!fontsLoaded && !fontError) {
     return null; // splash still visible — waiting for fonts
   }
   ```

5. Add the FontErrorScreen render path:
   ```tsx
   if (fontError) {
     return (
       <FontErrorScreen
         onRetry={() => {
           if (Platform.OS === 'web') {
             // @ts-ignore — window is available on web
             window.location.reload();
           } else {
             setRetryKey(k => k + 1);
           }
         }}
       />
     );
   }
   ```

6. Add imports at the top:
   - `import React, { useEffect, useState } from 'react';`  (add `useState` to existing import if not there)
   - `import { Platform } from 'react-native';`
   - `import FontErrorScreen from '../components/layout/FontErrorScreen';`

The key-reset retry (`setRetryKey`) only resets state in the component — it won't actually re-trigger useFonts unless the whole component remounts. To force a remount, wrap the `<CartProvider><Stack/></CartProvider>` return in a `<React.Fragment key={retryKey}>` — but since FontErrorScreen is rendered at the same level, increment retryKey on retry will force RootLayout to remount itself on next render. A simpler approach: render `<RootLayoutInner key={retryKey} />` where Inner contains all the actual layout. Document in a code comment that on native, this triggers font reattempt via component remount.

For simplicity and correctness, implement it as: on retry, on web reload the page, on native show a "Please close and reopen the app" message in a second Text below the retry button (update FontErrorScreen to accept a `nativeRetryFailed` prop, or handle it inline). Per the research, the key-reset approach may not reliably re-trigger expo-font's cache — native retry is a best-effort.

Actually use the simplest correct approach: retry on web = `window.location.reload()`. Retry on native = pass a callback that sets retryKey state but wrap the entire RootLayout body in a key. Wrap the successful return (`<CartProvider>...`) inside a fragment with the retryKey: `return <CartProvider key={retryKey}>...`. If user taps retry and it's native, incrementing retryKey remounts CartProvider tree but `_layout` itself doesn't remount — so for native, show a note: "Try closing and reopening the app." Accept this as the documented limitation since expo-updates is not installed.

Final implementation summary for `_layout.tsx`:
- `const [retryKey, setRetryKey] = useState(0);`
- Destructure fontError from useFonts
- useEffect: `if (fontsLoaded || fontError) SplashScreen.hideAsync()`
- Guard: `if (!fontsLoaded && !fontError) return null`
- fontError path: return `<FontErrorScreen onRetry={handleRetry} />`
- handleRetry: web → `window.location.reload()`, native → `setRetryKey(k => k+1)`
- Success path: `<CartProvider key={retryKey}><Stack/></CartProvider>` (key ensures remount on retry)
  </action>
  <verify>
TypeScript check: `npx tsc --noEmit` passes (or shows only pre-existing errors unrelated to this file).
Inspect `app/_layout.tsx`: confirm `fontError` is destructured from `useFonts`, confirm `SplashScreen.hideAsync()` is called in useEffect when `fontsLoaded || fontError`, confirm `FontErrorScreen` is rendered when `fontError` is truthy.
  </verify>
  <done>
`app/_layout.tsx` destructures `[fontsLoaded, fontError]` from useFonts. The useEffect calls `SplashScreen.hideAsync()` when either is truthy. The early return guard checks `!fontsLoaded && !fontError`. FontErrorScreen is rendered when `fontError` is set.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FontErrorScreen component</name>
  <files>components/layout/FontErrorScreen.tsx</files>
  <action>
Create `components/layout/FontErrorScreen.tsx`. This component is shown when custom fonts fail to load, so it MUST NOT use any custom font families (`fonts.heading`, `fonts.body`, etc.) — those fonts are unavailable. Use system serif fallbacks.

Create the `components/layout/` directory if it doesn't exist.

Component interface:
```tsx
interface FontErrorScreenProps {
  onRetry: () => void;
}
```

Implementation requirements:

1. Import: `SafeAreaView` from `react-native-safe-area-context` (not `react-native`), `Platform`, `StyleSheet`, `Text`, `TouchableOpacity`, `View` from `react-native`. Import `colors` from `../../constants/theme`.

2. Background: `colors.parchment` on the SafeAreaView container.

3. Text content (Wildenflower voice — warm, poetic, not technical):
   - Primary message: `"The flowers are still waking up…"` (large, warm tone)
   - Secondary message: `"Something kept our fonts from blooming. Please give us a moment."` (smaller, gentle)
   - On native only, add a third line: `"Try closing and reopening the app if this persists."` (using `Platform.OS !== 'web'` conditional)

4. Retry button:
   - Label: `"Try again"`
   - Style: background `colors.gold`, text color `colors.earth`, border radius `radii.button` (12), padding generous (16px vertical, 32px horizontal)
   - Renders for both platforms

5. Typography (system serif only — NO `fonts.*` values):
   ```tsx
   const systemSerif = Platform.select({
     web: { fontFamily: 'Georgia, "Times New Roman", serif' },
     default: { fontFamily: undefined }, // system default
   });
   ```
   Apply `systemSerif` to all Text components. Primary message: fontSize 22, color `colors.terracotta`. Secondary message: fontSize 15, color `colors.earth`. Button label: fontSize 16, fontWeight: '600', color `colors.earth`.

6. Layout: centered vertically and horizontally, generous padding (`spacing.xl` = 24px on sides), gap between elements (`spacing.xl` between message and button).

7. Do NOT import `radii` if not already in scope — just use the raw value 12 for button border radius to keep imports minimal (or import `radii` from theme, either is fine since theme.ts has no font loading dependency).

The component must follow the CLAUDE.md rules: `colors.parchment` background, warm earth tones, no pure white or black, no sans-serif fonts, no urgency. The retry button should feel like a gentle invitation, not a technical "Reload" button.
  </action>
  <verify>
File exists at `components/layout/FontErrorScreen.tsx`.
Inspect: confirms `SafeAreaView` imported from `react-native-safe-area-context`, no `fontFamily` values from `fonts.*` token (only system serif fallback), `colors.parchment` background, retry button present with onRetry prop wired to onPress.
TypeScript check passes: `npx tsc --noEmit`.
  </verify>
  <done>
`components/layout/FontErrorScreen.tsx` exists, uses system serif fonts only, has parchment background, renders warm Wildenflower error message and a gold retry button that calls `onRetry` on press.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` from project root — no new TypeScript errors introduced by these two files.
2. Inspect `app/_layout.tsx` and confirm the three-state font handling: null (loading), FontErrorScreen (error), Stack (success).
3. Inspect `components/layout/FontErrorScreen.tsx` and confirm no `fonts.*` token usage (grep for `fonts\.` in the file — should return nothing).
</verification>

<success_criteria>
- `app/_layout.tsx` handles `fontError` — SplashScreen.hideAsync() fires on error, FontErrorScreen renders when fontError is truthy
- `components/layout/FontErrorScreen.tsx` exists with system serif fallback fonts, parchment background, and retry button
- No TypeScript errors introduced
- ASSET-01 requirement addressed: font error state handled to prevent frozen splash
</success_criteria>

<output>
After completion, create `.planning/phases/01-prerequisites/01-01-SUMMARY.md`
</output>
