---
phase: 06-browse-product-detail
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - app/(tabs)/browse.tsx
autonomous: true
requirements: [COMM-02]

must_haves:
  truths:
    - "Finder sees a FilterChipRow with 'All' plus one chip per productCategory"
    - "Tapping a filter chip replaces the active filter and re-fetches from the matching Shopify collection"
    - "Active filter chip shows watercolor wash background (dustyRose)"
    - "While a new collection is loading, skeleton cards appear in the grid"
    - "When a filtered collection has no products, a warm empty state message appears"
    - "A 'Discover more' button appears below the grid only when more pages exist (pageInfo.hasNextPage)"
    - "Tapping 'Discover more' loads the next page and appends products to the grid"
    - "Browse screen can be pre-filtered by a category param passed from the Home screen"
    - "Tapping a product card navigates to /product/{handle}"
  artifacts:
    - path: "app/(tabs)/browse.tsx"
      provides: "Complete Browse screen with FilterChipRow, ProductGrid, pagination, skeleton loading"
      min_lines: 200
  key_links:
    - from: "app/(tabs)/browse.tsx"
      to: "hooks/useProducts"
      via: "useProducts({ collection: activeCollection ?? undefined, limit: 20 })"
      pattern: "useProducts"
    - from: "app/(tabs)/browse.tsx"
      to: "app/product/[id].tsx"
      via: "router.push(`/product/${product.handle}`)"
      pattern: "product\\.handle"
    - from: "FilterChip tap"
      to: "useProducts collection param"
      via: "setActiveCollection"
      pattern: "setActiveCollection"
---

<objective>
Build the complete Browse screen: FilterChipRow (collection-based single-select filtering), ProductGrid displaying live Shopify products with skeleton loading states, and a "Discover more" tap-to-paginate button using the upgraded useProducts hook.

Purpose: Completes COMM-02 — finder can browse all products filtered by Shopify collection.
Output: app/(tabs)/browse.tsx fully implemented to match wildenflowerProductListing.png
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-browse-product-detail/06-RESEARCH.md
@.planning/phases/06-browse-product-detail/06-01-SUMMARY.md
@constants/theme.ts
@app/(tabs)/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Browse screen with filtering, skeleton loading, and pagination</name>
  <files>app/(tabs)/browse.tsx</files>
  <action>
Replace the stub browse.tsx with the complete Browse screen implementation. The screen matches wildenflowerProductListing.png: compact BotanicalHeader, page title, FilterChipRow, 2-column ProductGrid, skeleton cards during load, "Discover more" button, warm empty state.

**Screen structure (top to bottom):**
1. BotanicalHeader variant="compact"
2. SectionTitle "Wander the Shop" (terracotta, Playfair Display Bold)
3. FilterChipRow (horizontal scroll)
4. ProductGrid or SkeletonGrid or empty state
5. "Discover more" button (conditional)
6. Bottom breathing room (paddingBottom: spacing.xl)

**Imports needed:**
```typescript
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, ScrollView, StyleSheet, ActivityIndicator } from 'react-native';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { colors, fonts, fontSizes, productCategories, spacing } from '../../constants/theme';
import { useFavorites } from '../../context/FavoritesContext';
import { useProducts } from '../../hooks/useProducts';
import type { AppProduct } from '../../lib/shopify-mappers';
import type { Product } from '../../types';
import Screen from '../../components/layout/Screen';
import BotanicalHeader from '../../components/BotanicalHeader';
import SectionTitle from '../../components/SectionTitle';
import ProductGrid from '../../components/ProductGrid';
import SkeletonProductCard from '../../components/SkeletonProductCard';
import PrimaryButton from '../../components/PrimaryButton';
```

**Category param from Home screen** (pre-filters Browse when tapped from CategoryRow):
```typescript
const { category } = useLocalSearchParams<{ category?: string | string[] }>();
const initialCategory = Array.isArray(category) ? category[0] ?? null : category ?? null;
const [activeCollection, setActiveCollection] = useState<string | null>(initialCategory);
```

**Data:**
```typescript
const { products: rawProducts, loading, isLoadingMore, error, loadMore } = useProducts({
  collection: activeCollection ?? undefined,
  limit: 20,
});
```

**Type adapter** (screen-local — do NOT export; same pattern as Home screen):
```typescript
function mapAppProductToProduct(p: AppProduct): Product {
  return {
    id: p.id,
    name: p.title,
    price: parseFloat(p.priceRange.minVariantPrice.amount),
    description: p.description,
    images: p.images.map((img) => img.url),
    category: p.productType || (p.tags[0] ?? ''),
    maker: {
      id: p.vendor.toLowerCase().replace(/\s+/g, '-'),
      name: p.vendor,
    },
    createdAt: new Date().toISOString(),
  };
}
```

**FilterChipRow** — inline (not a separate component). A horizontal ScrollView of pill buttons. First chip is always "All":
```typescript
const allChips = [{ id: null, label: 'All' }, ...productCategories.map(c => ({ id: c.id, label: c.label }))];
```

Each chip:
- Active: backgroundColor dustyRose, borderColor terracotta, text color earth
- Inactive: backgroundColor transparent (or parchment), borderColor border, text color sage
- On press: `setActiveCollection(chip.id)` (null for "All")
- Pill shape: borderRadius: spacing.round (999), paddingHorizontal: spacing.md, paddingVertical: spacing.xs
- Font: fonts.body, fontSize: fontSizes.bodySmall

Active chip background — use a flat backgroundColor (colors.dustyRose at 40% opacity via rgba) rather than the WatercolorWash component, to keep the chip row simple. The active visual distinction must be clearly visible (dustyRose bg + terracotta border + earth text).

**SkeletonGrid** — same pattern as Home screen (6 SkeletonProductCards in a two-column layout):
```typescript
function SkeletonGrid() {
  const left = [0, 2, 4];
  const right = [1, 3, 5];
  return (
    <View style={styles.skeletonGrid}>
      <View style={styles.skeletonCol}>{left.map(i => <SkeletonProductCard key={i} style={styles.skeletonCard} />)}</View>
      <View style={styles.skeletonCol}>{right.map(i => <SkeletonProductCard key={i} style={styles.skeletonCard} />)}</View>
    </View>
  );
}
```

**Navigation** — CRITICAL: use `product.handle`, NOT `product.id` (which is a Shopify GID):
```typescript
function handleProductPress(product: Product) {
  // product.id here is the Shopify GID — but we need the handle for useProduct() in [id].tsx.
  // The Product type's id field was set from AppProduct.id (GID) in mapAppProductToProduct.
  // Fix: pass handle via a separate mechanism.
}
```

Actually, since the local Product type only carries `id` (GID) and ProductGrid's onProductPress receives `Product`, we cannot get handle from it. Work around: in `mapAppProductToProduct`, store the handle in the `id` field instead:
```typescript
function mapAppProductToProduct(p: AppProduct): Product {
  return {
    id: p.handle,  // Store handle here — [id].tsx route reads this as the handle
    name: p.title,
    ...
  };
}
```
This is the same fix needed in `index.tsx` (handled in Plan 03), but for Browse it is done here first. The `[id].tsx` route param is named `id` but semantically is the handle.

**Product Grid section logic:**
```typescript
const displayProducts = rawProducts.map(mapAppProductToProduct);
const { toggleFavorite, isFavorite } = useFavorites();
const favoritedIds = displayProducts.map(p => p.id).filter(id => isFavorite(id));

// Show skeleton when loading AND no products yet (initial load or filter change)
const showSkeleton = loading && displayProducts.length === 0;
const showEmpty = !loading && !error && displayProducts.length === 0;
const showError = !loading && error !== null && displayProducts.length === 0;
```

**"Discover more" button** — only shown when loadMore is non-null:
```typescript
{loadMore !== null && (
  <View style={styles.discoverMore}>
    {isLoadingMore ? (
      <ActivityIndicator color={colors.terracotta} />
    ) : (
      <PrimaryButton
        label="Discover more"
        onPress={loadMore}
        variant="terracotta"
      />
    )}
  </View>
)}
```

**Empty state copy** (use brand vocabulary):
- Empty collection: "Nothing has wandered here yet."
- Error: "The shop is resting.\nTry again soon." + "Try Again" PrimaryButton calling `refetch()`

Wait — `refetch` is also needed. Add it to the useProducts destructure:
```typescript
const { products: rawProducts, loading, isLoadingMore, error, loadMore, refetch } = useProducts({...});
```

**Screen wrapper:** Use `Screen` (not ScrollScreen) because we need a custom ScrollView for the content. Structure:
```typescript
<Screen>
  <ScrollView showsVerticalScrollIndicator={false} contentContainerStyle={styles.scrollContent}>
    <BotanicalHeader variant="compact" />
    <SectionTitle title="Wander the Shop" />
    {/* FilterChipRow */}
    <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.chips}>
      {allChips.map(chip => (...))}
    </ScrollView>
    {/* Content area */}
    {showSkeleton && <SkeletonGrid />}
    {showError && <ErrorState onRetry={refetch} />}
    {showEmpty && <EmptyState />}
    {!showSkeleton && !showError && !showEmpty && (
      <ProductGrid
        products={displayProducts}
        onProductPress={handleProductPress}
        onFavoriteToggle={toggleFavorite}
        favorites={favoritedIds}
      />
    )}
    {/* Discover more */}
    {loadMore !== null && (...)}
    <View style={{ height: spacing.xl }} />
  </ScrollView>
</Screen>
```

**handleProductPress:**
```typescript
function handleProductPress(product: Product) {
  router.push(`/product/${product.id}`);  // product.id holds handle (see mapAppProductToProduct above)
}
```

**StyleSheet tokens:** All colors from `colors.*`, all spacing from `spacing.*`, all fonts from `fonts.*`, all font sizes from `fontSizes.*`. No hardcoded values. Background parchment on Screen.

**BotanicalHeader variant:** Use `"compact"` if BotanicalHeader accepts that variant; check the component for accepted variants and use the smallest/most compact one available.
  </action>
  <verify>
1. `npx tsc --noEmit` — zero errors
2. In Expo dev server: Browse tab renders without crash
3. All filter chips visible in horizontal scroll; tapping "Leather" shows leather products; tapping "All" shows all products
4. Skeleton grid appears during collection load transition
5. "Discover more" button appears when hasNextPage is true (may not appear if store has few products)
  </verify>
  <done>Browse screen renders with BotanicalHeader, FilterChipRow (All + 4 collection chips), live ProductGrid from Shopify, skeleton loading states, "Discover more" pagination button when applicable, and brand-voiced empty/error states. TypeScript clean.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Browse tab shows compact BotanicalHeader and "Wander the Shop" title
- FilterChipRow has "All" + tie-dye, leather, jewelry, artwork chips
- Active chip is visually distinct (dustyRose background)
- Tapping a chip re-fetches from that collection; skeleton appears during load
- Tapping a product navigates to product detail (handle in URL, not GID)
- "Discover more" button conditional on hasNextPage
- Empty/error states show warm brand-voiced copy
</verification>

<success_criteria>
Browse screen fully implemented: collection filtering, skeleton loading, ProductGrid with live data, cursor pagination via "Discover more", brand-faithful styling. COMM-02 complete.
</success_criteria>

<output>
After completion, create `.planning/phases/06-browse-product-detail/06-02-SUMMARY.md`
</output>
