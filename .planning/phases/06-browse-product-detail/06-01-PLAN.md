---
phase: 06-browse-product-detail
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/useProducts.ts
  - constants/theme.ts
autonomous: true
requirements: [COMM-02]

must_haves:
  truths:
    - "useProducts returns pageInfo and a loadMore() function when more pages exist"
    - "useProducts resets accumulated products when collection filter changes"
    - "productCategories in theme.ts contains only handles that exist in the Shopify store"
    - "The 'All' chip maps to no collection handle (unfiltered view)"
  artifacts:
    - path: "hooks/useProducts.ts"
      provides: "Upgraded hook with cursor accumulation, pageInfo, loadMore, isLoadingMore"
      exports: ["useProducts", "UseProductsOptions", "UseProductsResult"]
    - path: "constants/theme.ts"
      provides: "productCategories aligned to confirmed Shopify handles"
      contains: "tie-dye, leather, jewelry, art"
  key_links:
    - from: "hooks/useProducts.ts"
      to: "lib/shopify-client.ts getProducts / getCollectionByHandle"
      via: "after: cursor parameter on pagination fetch"
      pattern: "after.*cursor"
    - from: "hooks/useProducts.ts"
      to: "loadMore"
      via: "setCursor(pageInfo.endCursor)"
      pattern: "setCursor"
---

<objective>
Upgrade useProducts to support cursor-based pagination with product accumulation, and fix the productCategories collection handle mismatch confirmed in Phase 2 smoke test.

Purpose: Both are foundational blockers for the Browse screen. Without cursor accumulation, "Discover more" cannot work. Without correct handles, filter chips will return empty results against the live Shopify store.
Output: Upgraded hooks/useProducts.ts + corrected constants/theme.ts productCategories
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-browse-product-detail/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade useProducts with cursor accumulation and pagination API</name>
  <files>hooks/useProducts.ts</files>
  <action>
Rewrite hooks/useProducts.ts to support cursor-based pagination with product accumulation. The upgraded hook must NOT use useShopifyQuery for pagination state (useShopifyQuery only manages a single fetch result). Instead, manage product state, cursor, pageInfo, and loading flags directly in useProducts itself.

Key implementation points:

**New return type** — add to UseProductsResult:
```typescript
interface UseProductsResult {
  products: AppProduct[];
  loading: boolean;        // true only on initial fetch (products=[] and no error yet)
  isRefetching: boolean;   // true on explicit refetch() calls
  isLoadingMore: boolean;  // true while a loadMore() fetch is in flight
  error: string | null;
  refetch: () => void;     // resets cursor and re-fetches from page 1
  pageInfo: ShopifyPageInfo | null;
  loadMore: (() => void) | null; // null when pageInfo.hasNextPage is false
}
```

**State management inside the hook:**
- `const [products, setProducts] = useState<AppProduct[]>([])`
- `const [cursor, setCursor] = useState<string | null>(null)`
- `const [pageInfo, setPageInfo] = useState<ShopifyPageInfo | null>(null)`
- `const [loading, setLoading] = useState(true)`
- `const [isRefetching, setIsRefetching] = useState(false)`
- `const [isLoadingMore, setIsLoadingMore] = useState(false)`
- `const [error, setError] = useState<string | null>(null)`
- `const [fetchTrigger, setFetchTrigger] = useState(0)` — increment to trigger refetch

**Reset on collection change** — use a separate useEffect that watches `collection`:
```typescript
useEffect(() => {
  setProducts([]);
  setCursor(null);
  setPageInfo(null);
  setLoading(true);
  setError(null);
}, [collection]);
```
This ensures filter changes show skeleton cards immediately (loading=true, products=[]).

**Fetch effect** — watches `[fetchTrigger, collection, limit, cursor]`:
- If `cursor` is null AND `products.length > 0` AND no fetchTrigger change: skip (collection-reset effect handles the re-fetch via setting loading=true, which the fetch effect should detect by also watching `loading`).

Actually, simpler: use a single combined effect. Use `fetchTrigger` as the trigger. The collection reset effect resets state. The fetch effect fires when either `fetchTrigger` OR `collection` changes (or `limit`). When collection changes, both effects fire: reset fires first (synchronous state update), fetch effect fires and sees cursor=null so it fetches from page 1.

Use a cancelled flag for race condition safety:
```typescript
useEffect(() => {
  let cancelled = false;
  const isCursorFetch = cursor !== null; // loadMore triggered this

  if (isCursorFetch) {
    setIsLoadingMore(true);
  } else {
    // Initial or refetch — show loading only if no products yet
    if (products.length === 0) setLoading(true);
    else setIsRefetching(true);
  }

  (async () => {
    try {
      let items: AppProduct[];
      let newPageInfo: ShopifyPageInfo;

      if (collection) {
        const result = await getCollectionByHandle(collection, { first: limit, after: cursor ?? undefined });
        items = result?.products.items ?? [];
        newPageInfo = result?.products.pageInfo ?? { hasNextPage: false, endCursor: null };
      } else {
        const result = await getProducts({ first: limit, after: cursor ?? undefined });
        items = result.items;
        newPageInfo = result.pageInfo;
      }

      if (!cancelled) {
        setProducts(prev => isCursorFetch ? [...prev, ...items] : items);
        setPageInfo(newPageInfo);
        setError(null);
      }
    } catch (err) {
      if (!cancelled) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      }
    } finally {
      if (!cancelled) {
        setLoading(false);
        setIsRefetching(false);
        setIsLoadingMore(false);
      }
    }
  })();

  return () => { cancelled = true; };
}, [fetchTrigger, collection, limit, cursor]);
```

**Note on the design:** The collection reset effect sets `products=[]` and `cursor=null`. The fetch effect fires when `collection` changes (it's in deps). Since `cursor` was just reset to null, `isCursorFetch` is false, so it does a fresh page 1 fetch and replaces (not appends) products.

**loadMore and refetch:**
```typescript
const loadMore = pageInfo?.hasNextPage && pageInfo.endCursor
  ? () => setCursor(pageInfo.endCursor!)
  : null;

function refetch() {
  setProducts([]);
  setCursor(null);
  setPageInfo(null);
  setError(null);
  setLoading(true);
  setFetchTrigger(n => n + 1);
}
```

Import `ShopifyPageInfo` from `'../types/shopify'`.
Import `useState, useEffect` from `'react'` (remove `useCallback` — no longer needed).
Keep the existing JSDoc comment about screens not importing shopify-client directly.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit` from project root.</verify>
  <done>useProducts exports UseProductsResult with pageInfo, loadMore, isLoadingMore fields; tsc clean; collection change resets accumulated products (logic verifiable by code inspection).</done>
</task>

<task type="auto">
  <name>Task 2: Fix productCategories handles to match actual Shopify collections</name>
  <files>constants/theme.ts</files>
  <action>
Update the `productCategories` export in constants/theme.ts to use only collection handles confirmed in Phase 2 smoke test. Current handles `crystals` and `ceramics` have no matching Shopify collections; `artwork` must be `art`.

Confirmed Shopify handles (from STATE.md Phase 2 blocker):
`frontpage`, `tie-dye`, `leather`, `jewelry`, `art`

Replace the existing `productCategories` array (lines ~330-337) with:
```typescript
export const productCategories = [
  { id: 'tie-dye',  label: 'Tie-Dye',  description: 'Color & Light',  icon: 'wildflower' },
  { id: 'leather',  label: 'Leather',  description: 'Hand Crafted',   icon: 'fern'       },
  { id: 'jewelry',  label: 'Jewelry',  description: 'Worn & Found',   icon: 'vine'       },
  { id: 'art',      label: 'Artwork',  description: 'Made by Hand',   icon: 'sunburst'   },
];
```

Rationale:
- `tie-dye`, `leather`, `jewelry`, `art` — all confirmed real Shopify handles
- `frontpage` omitted — treated as "All" (unfiltered); not useful as an additional chip
- `crystals`, `ceramics` removed — no matching Shopify collections exist
- `artwork` label kept (user-facing label); `art` is the handle (Shopify's slug) — these are different fields
- The "All" chip is synthetic (rendered by Browse screen, not from this array); it maps to `collection: undefined`

No other files reference the specific `id` values of productCategories except the Home screen (which passes them as navigation params to Browse) and Browse (being built in plan 02).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. `grep -n "crystals\|ceramics" constants/theme.ts` returns no results.</verify>
  <done>productCategories has 4 entries with ids: tie-dye, leather, jewelry, art. No crystals or ceramics entries remain.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `hooks/useProducts.ts` exports `UseProductsResult` with `pageInfo`, `loadMore`, `isLoadingMore` fields
- `constants/theme.ts` `productCategories` contains exactly 4 entries: tie-dye, leather, jewelry, art
- No `crystals` or `ceramics` entries remain in productCategories
- Code inspection confirms: when collection changes, products[] is reset to [] before re-fetch
- Code inspection confirms: when cursor is non-null, new items are appended (not replaced)
</verification>

<success_criteria>
useProducts hook supports cursor-based pagination with product accumulation; productCategories aligned to confirmed Shopify handles. Both Browse screen plans (06-02) can now be built on this foundation.
</success_criteria>

<output>
After completion, create `.planning/phases/06-browse-product-detail/06-01-SUMMARY.md`
</output>
