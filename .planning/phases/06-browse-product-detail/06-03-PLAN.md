---
phase: 06-browse-product-detail
plan: 03
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - app/product/[id].tsx
  - app/(tabs)/index.tsx
autonomous: true
requirements: [COMM-03]

must_haves:
  truths:
    - "Tapping a product on the Home screen navigates to the correct product detail page (uses handle, not GID)"
    - "Product Detail shows a full-width image gallery with dot indicators"
    - "On web, prev/next arrow buttons are always visible on the gallery image edges"
    - "Variant option pills render for each option dimension; unavailable options show strikethrough"
    - "No variant is pre-selected; Add to Cart is disabled until a valid variant is chosen"
    - "The disabled button reads 'Select options to add' not 'Add to Cart'"
    - "Tapping Add to Cart calls CartContext.addToCart(variantId); button shows 'Added!' for 1.5s then resets"
    - "Price and Add to Cart button live in a sticky bottom bar visible at all scroll positions"
    - "Product Detail renders correctly on Expo Web with no layout breakage"
  artifacts:
    - path: "app/product/[id].tsx"
      provides: "Complete Product Detail screen: image gallery, variant selector, sticky bottom bar, maker info"
      min_lines: 280
    - path: "app/(tabs)/index.tsx"
      provides: "Navigation fix: product.handle used in router.push instead of product.id (GID)"
  key_links:
    - from: "app/product/[id].tsx"
      to: "hooks/useProduct"
      via: "const { id: handle } = useLocalSearchParams(); useProduct(handle)"
      pattern: "useProduct"
    - from: "variant selector"
      to: "CartContext.addToCart"
      via: "addToCart(selectedVariant.id)"
      pattern: "addToCart"
    - from: "app/(tabs)/index.tsx handleProductPress"
      to: "app/product/[id].tsx"
      via: "router.push(`/product/${product.handle}`)"
      pattern: "product\\.handle"
---

<objective>
Build the Product Detail screen with a swipeable image gallery, multi-option variant selector with availability markings, and a sticky Add to Cart bottom bar. Fix the Home screen navigation to use product.handle (not GID) so the useProduct hook can find the product.

Purpose: Completes COMM-03 — finder can view product images, select a variant, and add it to the Shopify cart.
Output: Complete app/product/[id].tsx + navigation fix in app/(tabs)/index.tsx
</objective>

<execution_context>
@/Users/jamesputman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesputman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-browse-product-detail/06-RESEARCH.md
@.planning/phases/06-browse-product-detail/06-01-SUMMARY.md
@app/(tabs)/index.tsx
@hooks/useProduct.ts
@context/CartContext.tsx
@types/shopify.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Home screen navigation to use product.handle</name>
  <files>app/(tabs)/index.tsx</files>
  <action>
The Home screen currently navigates to product detail using `product.id` (which is the Shopify GID like `gid://shopify/Product/12345`). The `useProduct(handle)` hook in product/[id].tsx expects a URL-safe handle like `tie-dye-tee`. Without this fix, tapping any product from Home results in "Product not found".

In `mapAppProductToProduct` in `app/(tabs)/index.tsx`, change the `id` field to use `p.handle` instead of `p.id`:

Current (line ~42):
```typescript
function mapAppProductToProduct(p: AppProduct): Product {
  return {
    id: p.id,
    ...
```

Change to:
```typescript
function mapAppProductToProduct(p: AppProduct): Product {
  return {
    id: p.handle,  // handle used as route param; useProduct(handle) expects this
    ...
```

The `handleProductPress` function already does `router.push(\`/product/${product.id}\`)` — this remains unchanged since `product.id` now holds the handle.

Also add a comment on `handleProductPress` clarifying the intent:
```typescript
function handleProductPress(product: Product) {
  // product.id holds the Shopify handle (set in mapAppProductToProduct above).
  // The [id] route param is named "id" but useProduct() treats it as a handle.
  router.push(`/product/${product.id}`);
}
```

No other changes to index.tsx. TypeScript will still be clean because `Product.id` is typed as `string` and `AppProduct.handle` is also `string`.

Note: The same fix is applied in browse.tsx (Plan 02) via its local mapAppProductToProduct. This keeps the adapter functions consistent: both Home and Browse map `AppProduct.handle → Product.id`.
  </action>
  <verify>`npx tsc --noEmit` — zero errors. Inspect the updated function: id field uses `p.handle`.</verify>
  <done>Home screen mapAppProductToProduct maps p.handle to Product.id. Navigation to product detail will use handle slug, not GID.</done>
</task>

<task type="auto">
  <name>Task 2: Build Product Detail screen with gallery, variant selector, and sticky bar</name>
  <files>app/product/[id].tsx</files>
  <action>
Replace the stub product/[id].tsx with the complete Product Detail screen. This screen uses `Screen` (not ScrollScreen) because of the sticky bottom bar.

**Imports:**
```typescript
import React, { useState, useRef } from 'react';
import {
  View, Text, ScrollView, Image, TouchableOpacity,
  StyleSheet, Platform, useWindowDimensions, ActivityIndicator,
} from 'react-native';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { colors, fonts, fontSizes, spacing } from '../../constants/theme';
import { useProduct } from '../../hooks/useProduct';
import { useCart } from '../../context/CartContext';
import type { ShopifyProductVariant } from '../../types/shopify';
import Screen from '../../components/layout/Screen';
import PrimaryButton from '../../components/PrimaryButton';
import BotanicalDivider from '../../components/BotanicalDivider';
```

**Handle from route:**
```typescript
const { id: handle } = useLocalSearchParams<{ id: string }>();
const router = useRouter();
const { product, loading, error } = useProduct(
  Array.isArray(handle) ? handle[0] : handle ?? ''
);
```

**Gallery state:**
```typescript
const { width } = useWindowDimensions();
const galleryWidth = Math.min(width, 600); // cap at 600 for web desktop
const galleryHeight = galleryWidth * (5 / 4); // 4:5 portrait ratio
const [currentIndex, setCurrentIndex] = useState(0);
const scrollRef = useRef<ScrollView>(null);
```

**Variant state:**
```typescript
const [selectedOptions, setSelectedOptions] = useState<Record<string, string>>({});
const [buttonState, setButtonState] = useState<'idle' | 'adding' | 'added'>('idle');
const { addToCart } = useCart();
```

**Loading / error states:**

If `loading`: show a centered ActivityIndicator in parchment screen.
If `error` or `!product`: show a warm error message:
```
"This piece has wandered off.\nTry finding it again."
```
with a back button that calls `router.back()`.

**Variant matching helpers** (define at module scope or inside component):

```typescript
function findVariant(
  variants: ShopifyProductVariant[],
  selectedOptions: Record<string, string>
): ShopifyProductVariant | null {
  const entries = Object.entries(selectedOptions);
  if (entries.length === 0) return null;
  return (
    variants.find((v) =>
      entries.every(([name, value]) =>
        v.selectedOptions.some((opt) => opt.name === name && opt.value === value)
      )
    ) ?? null
  );
}

// Global unavailability (v1 simplification — see RESEARCH.md Pitfall 3)
function getUnavailableValues(variants: ShopifyProductVariant[], optionName: string): Set<string> {
  const unavailable = new Set<string>();
  const allValues = new Set(
    variants.flatMap((v) =>
      v.selectedOptions.filter((o) => o.name === optionName).map((o) => o.value)
    )
  );
  allValues.forEach((val) => {
    const hasAvailable = variants.some(
      (v) =>
        v.selectedOptions.some((o) => o.name === optionName && o.value === val) &&
        v.availableForSale
    );
    if (!hasAvailable) unavailable.add(val);
  });
  return unavailable;
}
```

**Derived variant:**
```typescript
const variants = product?.variants ?? [];
const optionNames = product?.options?.map(o => o.name) ?? [];
const allOptionsSelected = optionNames.length > 0 && optionNames.every(name => selectedOptions[name]);
const selectedVariant = allOptionsSelected ? findVariant(variants, selectedOptions) : null;
```

Note: `product.options` comes from the Shopify product — check that ShopifyProduct type includes `options`. If not available on AppProduct, derive option names from variants:
```typescript
const optionNames = variants.length > 0
  ? Array.from(new Set(variants.flatMap(v => v.selectedOptions.map(o => o.name))))
  : [];
```

**Add to Cart handler:**
```typescript
async function handleAddToCart() {
  if (!selectedVariant || buttonState !== 'idle') return;
  setButtonState('adding');
  const success = await addToCart(selectedVariant.id);
  if (success) {
    setButtonState('added');
    setTimeout(() => setButtonState('idle'), 1500);
  } else {
    setButtonState('idle');
    // No persistent error state — CartContext returns boolean; screen shows nothing on failure
  }
}
```

**Web gallery prev/next:**
```typescript
function handlePrev() {
  if (currentIndex === 0) return;
  const newIndex = currentIndex - 1;
  scrollRef.current?.scrollTo({ x: newIndex * galleryWidth, animated: true });
  setCurrentIndex(newIndex);
}
function handleNext() {
  const images = product?.images ?? [];
  if (currentIndex === images.length - 1) return;
  const newIndex = currentIndex + 1;
  scrollRef.current?.scrollTo({ x: newIndex * galleryWidth, animated: true });
  setCurrentIndex(newIndex);
}
```

**Screen layout (Screen = SafeAreaView wrapper, flex:1):**

```
<Screen>
  {/* Scrollable content */}
  <ScrollView flex:1 showsVerticalScrollIndicator:false>
    {/* Gallery */}
    <View style={{ position: 'relative' }}>
      <ScrollView
        ref={scrollRef}
        horizontal
        pagingEnabled
        showsHorizontalScrollIndicator={false}
        scrollEventThrottle={16}
        onScroll={(e) => {
          const idx = Math.round(e.nativeEvent.contentOffset.x / galleryWidth);
          setCurrentIndex(idx);
        }}
        style={{ width: galleryWidth, height: galleryHeight }}
      >
        {images.map((img, i) => (
          <Image key={i} source={{ uri: img.url }} style={{ width: galleryWidth, height: galleryHeight }} resizeMode="cover" />
        ))}
      </ScrollView>

      {/* Web prev/next buttons — always visible on web */}
      {Platform.OS === 'web' && images.length > 1 && (
        <>
          {currentIndex > 0 && (
            <TouchableOpacity style={styles.prevButton} onPress={handlePrev}>
              <Text style={styles.arrowText}>‹</Text>
            </TouchableOpacity>
          )}
          {currentIndex < images.length - 1 && (
            <TouchableOpacity style={styles.nextButton} onPress={handleNext}>
              <Text style={styles.arrowText}>›</Text>
            </TouchableOpacity>
          )}
        </>
      )}
    </View>

    {/* Dot indicators */}
    {images.length > 1 && (
      <View style={styles.dots}>
        {images.map((_, i) => (
          <View key={i} style={[styles.dot, i === currentIndex && styles.dotActive]} />
        ))}
      </View>
    )}

    {/* Product info */}
    <View style={styles.info}>
      <Text style={styles.productTitle}>{product.title}</Text>
      {product.vendor ? (
        <Text style={styles.makerName}>by {product.vendor}</Text>
      ) : null}
    </View>

    <BotanicalDivider variant="fern" />

    {/* Variant selector */}
    {optionNames.map(optionName => {
      const unavailable = getUnavailableValues(variants, optionName);
      const values = Array.from(new Set(variants.flatMap(v =>
        v.selectedOptions.filter(o => o.name === optionName).map(o => o.value)
      )));
      return (
        <View key={optionName} style={styles.optionGroup}>
          <Text style={styles.optionLabel}>{optionName}</Text>
          <View style={styles.optionPills}>
            {values.map(value => {
              const isUnavailable = unavailable.has(value);
              const isSelected = selectedOptions[optionName] === value;
              return (
                <TouchableOpacity
                  key={value}
                  style={[styles.pill, isSelected && styles.pillSelected, isUnavailable && styles.pillUnavailable]}
                  onPress={() => {
                    if (!isUnavailable) {
                      setSelectedOptions(prev => ({ ...prev, [optionName]: value }));
                    }
                  }}
                  disabled={isUnavailable}
                >
                  <Text style={[styles.pillText, isSelected && styles.pillTextSelected, isUnavailable && styles.pillTextUnavailable]}>
                    {value}
                  </Text>
                  {/* Strikethrough on unavailable */}
                  {isUnavailable && <View style={styles.strikethrough} />}
                </TouchableOpacity>
              );
            })}
          </View>
        </View>
      );
    })}

    {/* Description */}
    <View style={styles.descriptionSection}>
      <Text style={styles.descriptionLabel}>The Story Behind This Piece</Text>
      <Text style={styles.descriptionText}>{product.description}</Text>
    </View>

    {/* Materials (from product.tags if present) */}

    <View style={{ height: spacing.xl }} />
  </ScrollView>

  {/* Sticky bottom bar — outside ScrollView */}
  <View style={styles.stickyBar}>
    <Text style={styles.stickyPrice}>
      ${parseFloat(product.priceRange.minVariantPrice.amount).toFixed(2)}
    </Text>
    <TouchableOpacity
      style={[
        styles.addButton,
        (!selectedVariant || buttonState === 'adding') && styles.addButtonDisabled,
      ]}
      onPress={handleAddToCart}
      disabled={!selectedVariant || buttonState !== 'idle'}
    >
      <Text style={styles.addButtonText}>
        {buttonState === 'added'
          ? 'Added!'
          : buttonState === 'adding'
          ? 'Adding...'
          : selectedVariant
          ? 'Add to Cart'
          : 'Select options to add'}
      </Text>
    </TouchableOpacity>
  </View>
</Screen>
```

**Key styles (use theme tokens):**
- stickyBar: borderTopWidth:1, borderTopColor:colors.border, paddingHorizontal:spacing.screenPadding, paddingVertical:spacing.md, flexDirection:'row', alignItems:'center', justifyContent:'space-between', backgroundColor:colors.parchment
- addButton: backgroundColor:colors.gold, borderRadius:spacing.round (999), paddingHorizontal:spacing.xl, paddingVertical:spacing.sm
- addButtonDisabled: backgroundColor:colors.border (muted), opacity:0.6
- addButtonText: fontFamily:fonts.heading, fontSize:fontSizes.button, color:colors.earth
- productTitle: fontFamily:fonts.heading, fontSize:fontSizes.h2, color:colors.terracotta
- makerName: fontFamily:fonts.accent, fontSize:fontSizes.body, color:colors.sage
- pill: borderWidth:1, borderColor:colors.border, borderRadius:spacing.round (999), paddingHorizontal:spacing.md, paddingVertical:spacing.xs, position:'relative', overflow:'hidden'
- pillSelected: borderColor:colors.terracotta, backgroundColor:colors.dustyRose + opacity
- strikethrough: position:'absolute', left:0, right:0, height:1, backgroundColor:colors.earth, top:'50%'
- prevButton/nextButton: position:'absolute', top:'50%' (or transform), backgroundColor semi-transparent parchment, borderRadius round, padding spacing.sm
- arrowText: fontFamily:fonts.heading, fontSize:40, color:colors.earth
- dots: flexDirection:'row', justifyContent:'center', paddingVertical:spacing.sm, gap:spacing.xs
- dot: width:6, height:6, borderRadius:3, backgroundColor:colors.border
- dotActive: backgroundColor:colors.terracotta

**Check AppProduct shape before implementing:** AppProduct extends ShopifyProduct with `options` field. Check types/shopify.ts for whether `ShopifyProduct.options` exists. If not, derive option names from variant.selectedOptions as shown above. Do NOT add new types — work with what exists.

**Single-variant products:** If the product has only one variant and no meaningful options (e.g., variant with title "Default Title"), auto-select it silently so the button says "Add to Cart" immediately. Detect this: `variants.length === 1 && variants[0].title === 'Default Title'`. In that case, initialize `selectedOptions` to an empty object but treat `selectedVariant` as `variants[0]` directly:
```typescript
const isSingleVariantProduct = variants.length === 1 && variants[0].title === 'Default Title';
const selectedVariant = isSingleVariantProduct
  ? variants[0]
  : (allOptionsSelected ? findVariant(variants, selectedOptions) : null);
```
  </action>
  <verify>
1. `npx tsc --noEmit` — zero errors
2. Tapping a product on the Home screen opens product detail without "Product not found"
3. Product title and vendor render in terracotta/sage serif fonts
4. Image gallery shows images; dot indicators visible below
5. On web: prev/next arrow buttons visible on image edges
6. Variant pills render for each option dimension
7. Unavailable variant pills have a strikethrough line
8. Sticky bottom bar is visible at all scroll positions
9. "Select options to add" shows when no variant selected; changes to "Add to Cart" after selection
10. Tapping Add to Cart shows "Added!" for ~1.5s
  </verify>
  <done>Product Detail screen fully implemented: image gallery with dots + web nav buttons, variant selector with availability markings, sticky bottom bar with correct button state machine. Navigation from Home uses handle. COMM-03 complete.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` zero errors
- Home screen product tap navigates to correct product (handle in URL, not GID)
- Product Detail gallery: swipeable on mobile, arrows on web, dots below
- Variant pills: renders all option dimensions, strikethrough on unavailable
- No pre-selection on load — button reads "Select options to add"
- After selection — button reads "Add to Cart"; after tap — "Added!" for 1.5s
- Sticky bar always visible while scrolling through description
- Single-variant products show "Add to Cart" immediately (no option selection required)
- Screen renders without layout issues on Expo Web
</verification>

<success_criteria>
Product Detail screen complete with all COMM-03 requirements: swipeable gallery, variant selection mapping to correct variantId, Add to Cart calling CartContext, confirmation feedback, sticky bottom bar. Home screen navigation fixed to use handle.
</success_criteria>

<output>
After completion, create `.planning/phases/06-browse-product-detail/06-03-SUMMARY.md`
</output>
